From 01735d6b24b264ca1332e567be0ff673f223fa33 Mon Sep 17 00:00:00 2001
From: huangyifeng <huangyifeng@eswincomputing.com>
Date: Mon, 11 Mar 2024 18:50:41 +0800
Subject: [PATCH 02/68] Added clk & reset driver:WIN2030-14758

Change-Id: I246e56b1e8146ce6c7ff4b9d2194230fd95732b6
---
 drivers/clk/Kconfig                   |    1 +
 drivers/clk/Makefile                  |    1 +
 drivers/clk/eswin/Kconfig             |   10 +
 drivers/clk/eswin/Makefile            |    9 +
 drivers/clk/eswin/clk-win2030.c       | 1219 +++++++++++++++++++++++++
 drivers/clk/eswin/clk.c               |  915 +++++++++++++++++++
 drivers/clk/eswin/clk.h               |  198 ++++
 drivers/clk/eswin/test/Kconfig        |    7 +
 drivers/clk/eswin/test/Makefile       |    6 +
 drivers/clk/eswin/test/clk_test_kmd.c |  425 +++++++++
 drivers/reset/Kconfig                 |    6 +
 drivers/reset/Makefile                |    2 +
 drivers/reset/reset-eswin.c           |  270 ++++++
 13 files changed, 3069 insertions(+)
 create mode 100755 drivers/clk/eswin/Kconfig
 create mode 100755 drivers/clk/eswin/Makefile
 create mode 100755 drivers/clk/eswin/clk-win2030.c
 create mode 100755 drivers/clk/eswin/clk.c
 create mode 100755 drivers/clk/eswin/clk.h
 create mode 100755 drivers/clk/eswin/test/Kconfig
 create mode 100755 drivers/clk/eswin/test/Makefile
 create mode 100755 drivers/clk/eswin/test/clk_test_kmd.c
 create mode 100755 drivers/reset/reset-eswin.c

--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -471,6 +471,7 @@ source "drivers/clk/actions/Kconfig"
 source "drivers/clk/analogbits/Kconfig"
 source "drivers/clk/baikal-t1/Kconfig"
 source "drivers/clk/bcm/Kconfig"
+source "drivers/clk/eswin/Kconfig"
 source "drivers/clk/hisilicon/Kconfig"
 source "drivers/clk/imgtec/Kconfig"
 source "drivers/clk/imx/Kconfig"
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -91,6 +91,7 @@ obj-$(CONFIG_CLK_BAIKAL_T1)		+= baikal-t
 obj-y					+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
+obj-y					+= eswin/
 obj-$(CONFIG_ARCH_HISI)			+= hisilicon/
 obj-y					+= imgtec/
 obj-y					+= imx/
--- /dev/null
+++ b/drivers/clk/eswin/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config COMMON_CLK_WIN2030
+	bool "Win2030 Clock Driver"
+	help
+	  Build the Eswin Win2030 clock driver based on the common clock framework.
+
+if COMMON_CLK_WIN2030
+	source "drivers/clk/eswin/test/Kconfig"
+endif
--- /dev/null
+++ b/drivers/clk/eswin/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Eswin Clock specific Makefile
+#
+
+obj-y	+= clk.o
+
+obj-$(CONFIG_COMMON_CLK_WIN2030)	+= clk-win2030.o
+obj-$(CONFIG_COMMON_CLK_WIN2030_TEST)	+= test/
\ No newline at end of file
--- /dev/null
+++ b/drivers/clk/eswin/clk-win2030.c
@@ -0,0 +1,1219 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <dt-bindings/reset/eswin,win2030-syscrg.h>
+#include <dt-bindings/clock/win2030-clock.h>
+
+#include "clk.h"
+
+/* clock parent list */
+static const char *const mux_u_cpu_root_3mux1_gfree_p[] = {"clk_pll_cpu", "clk_clk_u84_core_lp", "fixed_rate_clk_xtal_24m"};
+static u32  mux_u_cpu_root_3mux1_gfree_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const mux_u_cpu_aclk_2mux1_gfree_p[] = {"fixed_factor_u_cpu_div2", "mux_u_cpu_root_3mux1_gfree"};
+
+static const char *const dsp_aclk_root_2mux1_gfree_mux_p[] = {"fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const d2d_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1", };
+
+static const char *const ddr_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1", };
+
+static const char *const mshcore_root_3mux1_0_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_0_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const mshcore_root_3mux1_1_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_1_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const mshcore_root_3mux1_2_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_2_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const npu_llclk_3mux1_gfree_mux_p[] = { "clk_clk_npu_llc_src0", "clk_clk_npu_llc_src1", "fixed_rate_clk_vpll_fout1"};
+static u32  npu_llclk_3mux1_gfree_mux_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const npu_core_3mux1_gfree_mux_p[] = { "fixed_rate_clk_spll1_fout1", "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+static u32  npu_core_3mux1_gfree_mux_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const npu_e31_3mux1_gfree_mux_p[] = { "fixed_rate_clk_spll1_fout1", "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+static u32  npu_e31_3mux1_gfree_mux_p_table[] = {0x000000, 0x000100, 0x000200};
+
+static const char *const vi_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vi_dw_root_2mux1_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vi_dvp_root_2mux1_gfree_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vi_dig_isp_root_2mux1_gfree_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vo_aclk_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vo_pixel_root_2mux1_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+
+static const char *const mux_u_vcdec_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vcaclk_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_syscfg_clk_root_2mux1_gfree_p[] = { "divder_u_sys_cfg_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_bootspi_clk_2mux1_gfree_p[] = {  "divder_u_bootspi_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_scpu_core_clk_2mux1_gfree_p[] = { "divder_u_scpu_core_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_lpcpu_core_clk_2mux1_gfree_p[] = {"divder_u_lpcpu_core_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_vo_mclk_2mux_ext_mclk_p[] = {"divder_u_vo_mclk_div_dynm", "fixed_rate_ext_mclk"};
+
+static const char *const mux_u_aondma_axi2mux1_gfree_p[] = { "divder_u_aondma_axi_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_rmii_ref_2mux1_p[] = { "fixed_factor_u_hsp_rmii_ref_div6", "fixed_rate_lpddr_ref_bak"};
+
+static const char *const mux_u_eth_core_2mux1_p[] = { "fixed_rate_clk_spll1_fout3", "fixed_rate_lpddr_ref_bak"};
+
+static const char *const mux_u_sata_phy_2mux1_p[] = { "divder_u_sata_phy_ref_div_dynm", "fixed_rate_lpddr_ref_bak"};
+
+/* fixed rate clocks */
+static struct eswin_fixed_rate_clock win2030_fixed_rate_clks[] = {
+	{ WIN2030_XTAL_24M,		"fixed_rate_clk_xtal_24m",	NULL, 0,	24000000, },
+	{ WIN2030_XTAL_32K,		"fixed_rate_clk_xtal_32k",	NULL, 0,	32768, },
+	{ WIN2030_SPLL0_FOUT1,		"fixed_rate_clk_spll0_fout1",	NULL, 0,	1600000000, },
+	{ WIN2030_SPLL0_FOUT2,		"fixed_rate_clk_spll0_fout2",	NULL, 0,	800000000, },
+	{ WIN2030_SPLL0_FOUT3,		"fixed_rate_clk_spll0_fout3",	NULL, 0,	400000000, },
+	{ WIN2030_SPLL1_FOUT1,		"fixed_rate_clk_spll1_fout1",	NULL, 0,	1500000000, },
+	{ WIN2030_SPLL1_FOUT2,  	"fixed_rate_clk_spll1_fout2",	NULL, 0,	300000000, },
+	{ WIN2030_SPLL1_FOUT3,		"fixed_rate_clk_spll1_fout3",	NULL, 0,	250000000, },
+	{ WIN2030_SPLL2_FOUT1,		"fixed_rate_clk_spll2_fout1",	NULL, 0,	2080000000, },
+	{ WIN2030_SPLL2_FOUT2,		"fixed_rate_clk_spll2_fout2",	NULL, 0,	1040000000, },
+	{ WIN2030_SPLL2_FOUT3,		"fixed_rate_clk_spll2_fout3",	NULL, 0,	416000000, },
+	{ WIN2030_VPLL_FOUT1,		"fixed_rate_clk_vpll_fout1",	NULL, 0,	1188000000, },
+	{ WIN2030_VPLL_FOUT2,		"fixed_rate_clk_vpll_fout2",	NULL, 0,	594000000, },
+	{ WIN2030_VPLL_FOUT3,		"fixed_rate_clk_vpll_fout3",	NULL, 0,	49500000, },
+	{ WIN2030_APLL_FOUT2,		"fixed_rate_clk_apll_fout2",	NULL, 0,	0, },
+	{ WIN2030_APLL_FOUT3,		"fixed_rate_clk_apll_fout3",	NULL, 0,	0, },
+	{ WIN2030_EXT_MCLK,		"fixed_rate_ext_mclk",		NULL, 0,	0, },
+	{ WIN2030_LPDDR_REF_BAK,	"fixed_rate_lpddr_ref_bak",	NULL, 0,	50000000, },
+	/*
+	{ WIN2030_PLL_DDR,		"fixed_rate_pll_ddr",		NULL, 0,	1066000000, },	//for ddr5, the clk should be 800M Hz
+	*/
+};
+
+static struct eswin_pll_clock win2030_pll_clks[] = {
+	{
+		WIN2030_APLL_FOUT1, "clk_apll_fout1", NULL,
+		WIN2030_REG_OFFSET_APLL_CFG_0, 0, 1, 12,6, 20,12,
+		WIN2030_REG_OFFSET_APLL_CFG_1, 4,24,
+		WIN2030_REG_OFFSET_APLL_CFG_2, 1,3, 16, 3,
+		WIN2030_REG_OFFSET_PLL_STATUS, 4, 1,
+	},
+	{
+		WIN2030_PLL_CPU, "clk_pll_cpu", NULL,
+		WIN2030_REG_OFFSET_MCPUT_PLL_CFG_0, 0,1, 12,6, 20,12,
+		WIN2030_REG_OFFSET_MCPUT_PLL_CFG_1, 4, 24,
+		WIN2030_REG_OFFSET_MCPUT_PLL_CFG_2, 1,3, 16,3,
+		WIN2030_REG_OFFSET_PLL_STATUS, 5, 1,
+	},
+};
+
+/* fixed factor clocks */
+static struct eswin_fixed_factor_clock win2030_fixed_factor_clks[] = {
+	{ WIN2030_FIXED_FACTOR_U_CPU_DIV2,	 "fixed_factor_u_cpu_div2",   "mux_u_cpu_root_3mux1_gfree", 1, 2, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_CLK_1M_DIV24,   "fixed_factor_u_clk_1m_div24",   "fixed_rate_clk_xtal_24m", 1, 24, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_MIPI_TXESC_DIV10, "fixed_factor_u_mipi_txesc_div10", "clk_clk_sys_cfg",  1, 10, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_U84_CORE_LP_DIV2,   "fixed_factor_u_u84_core_lp_div2",   "gate_clk_spll0_fout2", 1, 2, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_SCPU_BUS_DIV2,   "fixed_factor_u_scpu_bus_div2",   "mux_u_scpu_core_clk_2mux1_gfree", 1, 2, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_LPCPU_BUS_DIV2, "fixed_factor_u_lpcpu_bus_div2", "mux_u_lpcpu_core_clk_2mux1_gfree",  1, 2, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_PCIE_CR_DIV2,   "fixed_factor_u_pcie_cr_div2",   "clk_clk_sys_cfg", 1, 2, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_PCIE_AUX_DIV4,   "fixed_factor_u_pcie_aux_div4",   "clk_clk_sys_cfg", 1, 4, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_PVT_DIV20, "fixed_factor_u_pvt_div20", "fixed_rate_clk_xtal_24m",  1, 20, 0, },
+
+	{ WIN2030_FIXED_FACTOR_U_HSP_RMII_REF_DIV6, "fixed_factor_u_hsp_rmii_ref_div6", "fixed_rate_clk_spll1_fout2",  1, 6, 0, },
+/*
+	{ WIN2030_FIXED_FACTOR_U_DRR_DIV8, "fixed_factor_u_ddr_div8", "fixed_rate_pll_ddr",  1, 8, 0, },
+*/
+};
+
+static struct eswin_mux_clock win2030_mux_clks[] = {
+	{ WIN2030_MUX_U_CPU_ROOT_3MUX1_GFREE, "mux_u_cpu_root_3mux1_gfree", mux_u_cpu_root_3mux1_gfree_p,
+		ARRAY_SIZE(mux_u_cpu_root_3mux1_gfree_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_U84_CLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, mux_u_cpu_root_3mux1_gfree_p_table, },
+
+	{ WIN2030_MUX_U_CPU_ACLK_2MUX1_GFREE, "mux_u_cpu_aclk_2mux1_gfree", mux_u_cpu_aclk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_cpu_aclk_2mux1_gfree_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_U84_CLK_CTRL,
+		20, 1, 0,},
+
+	{ WIN2030_MUX_U_DSP_ACLK_ROOT_2MUX1_GFREE, "mux_u_dsp_aclk_root_2mux1_gfree", dsp_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(dsp_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_DSP_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ WIN2030_MUX_U_D2D_ACLK_ROOT_2MUX1_GFREE, "mux_u_d2d_aclk_root_2mux1_gfree", d2d_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(d2d_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_D2D_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ WIN2030_MUX_U_DDR_ACLK_ROOT_2MUX1_GFREE, "mux_u_ddr_aclk_root_2mux1_gfree", ddr_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(ddr_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_DDR_CLK_CTRL,
+		16, 1, 0,},
+
+	{ WIN2030_MUX_U_MSHCORE_ROOT_3MUX1_0, "mux_u_mshcore_root_3mux1_0", mshcore_root_3mux1_0_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_0_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_MSHC0_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_0_mux_p_table},
+
+	{ WIN2030_MUX_U_MSHCORE_ROOT_3MUX1_1, "mux_u_mshcore_root_3mux1_1", mshcore_root_3mux1_1_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_1_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_MSHC1_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_1_mux_p_table, },
+
+	{ WIN2030_MUX_U_MSHCORE_ROOT_3MUX1_2, "mux_u_mshcore_root_3mux1_2", mshcore_root_3mux1_2_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_2_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_MSHC2_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_2_mux_p_table },
+
+	{ WIN2030_MUX_U_NPU_LLCLK_3MUX1_GFREE, "mux_u_npu_llclk_3mux1_gfree", npu_llclk_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_llclk_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_NPU_LLC_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, npu_llclk_3mux1_gfree_mux_p_table},
+
+	{ WIN2030_MUX_U_NPU_CORE_3MUX1_GFREE, "mux_u_npu_core_3mux1_gfree", npu_core_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_core_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_NPU_CORE_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, npu_core_3mux1_gfree_mux_p_table},
+
+	{ WIN2030_MUX_U_NPU_E31_3MUX1_GFREE, "mux_u_npu_e31_3mux1_gfree", npu_e31_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_e31_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_NPU_CORE_CTRL,
+		0, BIT_MASK(8) | BIT_MASK(9), 0, npu_e31_3mux1_gfree_mux_p_table},
+
+	{ WIN2030_MUX_U_VI_ACLK_ROOT_2MUX1_GFREE, "mux_u_vi_aclk_root_2mux1_gfree", vi_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(vi_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VI_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ WIN2030_MUX_U_VI_DW_ROOT_2MUX1, "mux_u_vi_dw_root_2mux1", mux_u_vi_dw_root_2mux1_p,
+		ARRAY_SIZE(mux_u_vi_dw_root_2mux1_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VI_DWCLK_CTRL,
+		0, 1, 0,},
+
+	{ WIN2030_MUX_U_VI_DVP_ROOT_2MUX1_GFREE, "mux_u_vi_dvp_root_2mux1_gfree", mux_u_vi_dvp_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vi_dvp_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VI_DVP_CLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VI_DIG_ISP_ROOT_2MUX1_GFREE, "mux_u_vi_dig_isp_root_2mux1_gfree", mux_u_vi_dig_isp_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vi_dig_isp_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VI_DIG_ISP_CLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VO_ACLK_ROOT_2MUX1_GFREE, "mux_u_vo_aclk_root_2mux1_gfree", mux_u_vo_aclk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vo_aclk_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VO_ACLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VO_PIXEL_ROOT_2MUX1, "mux_u_vo_pixel_root_2mux1", mux_u_vo_pixel_root_2mux1_p,
+		ARRAY_SIZE(mux_u_vo_pixel_root_2mux1_p), CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VO_PIXEL_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VCDEC_ROOT_2MUX1_GFREE,  "mux_u_vcdec_root_2mux1_gfree",  mux_u_vcdec_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vcdec_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VCDEC_ROOTCLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VCACLK_ROOT_2MUX1_GFREE,  "mux_u_vcaclk_root_2mux1_gfree",  mux_u_vcaclk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vcaclk_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VC_ACLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_SYSCFG_CLK_ROOT_2MUX1_GFREE,  "mux_u_syscfg_clk_root_2mux1_gfree",  mux_u_syscfg_clk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_syscfg_clk_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_SYSCFG_CLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_BOOTSPI_CLK_2MUX1_GFREE,  "mux_u_bootspi_clk_2mux1_gfree",  mux_u_bootspi_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_bootspi_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_BOOTSPI_CLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_SCPU_CORE_CLK_2MUX1_GFREE,  "mux_u_scpu_core_clk_2mux1_gfree",  mux_u_scpu_core_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_scpu_core_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_SCPU_CORECLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_LPCPU_CORE_CLK_2MUX1_GFREE,  "mux_u_lpcpu_core_clk_2mux1_gfree",  mux_u_lpcpu_core_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_lpcpu_core_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_LPCPU_CORECLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_VO_MCLK_2MUX_EXT_MCLK,  "mux_u_vo_mclk_2mux_ext_mclk",  mux_u_vo_mclk_2mux_ext_mclk_p,
+		ARRAY_SIZE(mux_u_vo_mclk_2mux_ext_mclk_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_VO_MCLK_CTRL,
+		0, 1, 0, },
+
+	{ WIN2030_MUX_U_AONDMA_AXI2MUX1_GFREE,  "mux_u_aondma_axi2mux1_gfree",  mux_u_aondma_axi2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_aondma_axi2mux1_gfree_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_AON_DMA_CLK_CTRL,
+		20, 1, 0, },
+
+	{ WIN2030_MUX_U_RMII_REF_2MUX,  "mux_u_rmii_ref_2mux1",  mux_u_rmii_ref_2mux1_p,
+		ARRAY_SIZE(mux_u_rmii_ref_2mux1_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_ETH0_CTRL,
+		2, 1, 0, },
+
+	{ WIN2030_MUX_U_ETH_CORE_2MUX1,  "mux_u_eth_core_2mux1",  mux_u_eth_core_2mux1_p,
+		ARRAY_SIZE(mux_u_eth_core_2mux1_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_ETH0_CTRL,
+		1, 1, 0, },
+
+	{ WIN2030_MUX_U_SATA_PHY_2MUX1,  "mux_u_sata_phy_2mux1",  mux_u_sata_phy_2mux1_p,
+		ARRAY_SIZE(mux_u_sata_phy_2mux1_p),  CLK_SET_RATE_PARENT, WIN2030_REG_OFFSET_SATA_OOB_CTRL,
+		9, 1, 0, },
+
+};
+
+/*The hardware decides vaule 0, 1 and 2 both means 2 divsor, so we have to add these ugly tables*/
+static struct clk_div_table u_3_bit_special_div_table[8];
+static struct clk_div_table u_4_bit_special_div_table[16];
+static struct clk_div_table u_6_bit_special_div_table[64];
+static struct clk_div_table u_7_bit_special_div_table[128];
+static struct clk_div_table u_8_bit_special_div_table[256];
+static struct clk_div_table u_11_bit_special_div_table[2048];
+static struct clk_div_table u_16_bit_special_div_table[65536];
+
+static struct eswin_divider_clock win2030_div_clks[] = {
+	{ WIN2030_DIVDER_U_SYS_CFG_DIV_DYNM, "divder_u_sys_cfg_div_dynm",   "fixed_rate_clk_spll0_fout3", 0,
+		WIN2030_REG_OFFSET_SYSCFG_CLK_CTRL, 4, 3, CLK_DIVIDER_ROUND_CLOSEST, u_3_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_NOC_NSP_DIV_DYNM,   "divder_u_noc_nsp_div_dynm", "fixed_rate_clk_spll2_fout1", 0,
+		WIN2030_REG_OFFSET_NOC_CLK_CTRL, 0, 3, CLK_DIVIDER_ROUND_CLOSEST, u_3_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_BOOTSPI_DIV_DYNM,       "divder_u_bootspi_div_dynm",     "gate_clk_spll0_fout2", 0,
+		WIN2030_REG_OFFSET_BOOTSPI_CLK_CTRL, 4, 6, CLK_DIVIDER_ROUND_CLOSEST, u_6_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_SCPU_CORE_DIV_DYNM,     "divder_u_scpu_core_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_SCPU_CORECLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_LPCPU_CORE_DIV_DYNM,     "divder_u_lpcpu_core_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_LPCPU_CORECLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_GPU_ACLK_DIV_DYNM,     "divder_u_gpu_aclk_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_GPU_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_DSP_ACLK_DIV_DYNM,     "divder_u_dsp_aclk_div_dynm",   "clk_clk_dsp_root", 0,
+		WIN2030_REG_OFFSET_DSP_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_D2D_ACLK_DIV_DYNM, "divder_u_d2d_aclk_div_dynm",   "mux_u_d2d_aclk_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_D2D_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_DDR_ACLK_DIV_DYNM, "divder_u_ddr_aclk_div_dynm",   "mux_u_ddr_aclk_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 20, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_HSP_ACLK_DIV_DYNM,   "divder_u_hsp_aclk_div_dynm", "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_HSP_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_ETH_TXCLK_DIV_DYNM_0,     "divder_u_eth_txclk_div_dynm_0",   "mux_u_eth_core_2mux1", 0,
+		WIN2030_REG_OFFSET_ETH0_CTRL, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_ETH_TXCLK_DIV_DYNM_1,     "divder_u_eth_txclk_div_dynm_1",   "mux_u_eth_core_2mux1", 0,
+		WIN2030_REG_OFFSET_ETH1_CTRL, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_MSHC_CORE_DIV_DYNM_0,     "divder_u_mshc_core_div_dynm_0",   "mux_u_mshcore_root_3mux1_0", 0,
+		WIN2030_REG_OFFSET_MSHC0_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ WIN2030_DIVDER_U_MSHC_CORE_DIV_DYNM_1,     "divder_u_mshc_core_div_dynm_1",   "mux_u_mshcore_root_3mux1_1", 0,
+		WIN2030_REG_OFFSET_MSHC1_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ WIN2030_DIVDER_U_MSHC_CORE_DIV_DYNM_2,     "divder_u_mshc_core_div_dynm_2",   "mux_u_mshcore_root_3mux1_2",  0,
+		WIN2030_REG_OFFSET_MSHC2_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ WIN2030_DIVDER_U_PCIE_ACLK_DIV_DYNM,   "divder_u_pcie_aclk_div_dynm", "fixed_rate_clk_spll2_fout2", 0,
+		WIN2030_REG_OFFSET_PCIE_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_NPU_ACLK_DIV_DYNM,        "divder_u_npu_aclk_div_dynm", "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_NPU_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_NPU_LLC_SRC0_DIV_DYNM,    "divder_u_npu_llc_src0_div_dynm",  "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_NPU_LLC_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_NPU_LLC_SRC1_DIV_DYNM,    "divder_u_npu_llc_src1_div_dynm",   "fixed_rate_clk_spll2_fout1", 0,
+		WIN2030_REG_OFFSET_NPU_LLC_CTRL, 8, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_NPU_CORECLK_DIV_DYNM,     "divder_u_npu_coreclk_div_dynm",   "mux_u_npu_core_3mux1_gfree", 0,
+		WIN2030_REG_OFFSET_NPU_CORE_CTRL, 4, 4, CLK_DIVIDER_ONE_BASED},
+
+	{ WIN2030_DIVDER_U_NPU_E31_DIV_DYNM,         "divder_u_npu_e31_div_dynm",   "mux_u_npu_e31_3mux1_gfree", 0,
+		WIN2030_REG_OFFSET_NPU_CORE_CTRL, 12, 4, CLK_DIVIDER_ONE_BASED},
+
+	{ WIN2030_DIVDER_U_VI_ACLK_DIV_DYNM,          "divder_u_vi_aclk_div_dynm",   "mux_u_vi_aclk_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_VI_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_DW_DIV_DYNM,            "divder_u_vi_dw_div_dynm",   "mux_u_vi_dw_root_2mux1", 0,
+		WIN2030_REG_OFFSET_VI_DWCLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_DVP_DIV_DYNM,        "divder_u_vi_dvp_div_dynm",   "mux_u_vi_dig_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_VI_DVP_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_DIG_ISP_DIV_DYNM,       "divder_u_vi_dig_isp_div_dynm", "mux_u_vi_dig_isp_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_VI_DIG_ISP_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_0,     "divder_u_vi_shutter_div_dynm_0",   "fixed_rate_clk_vpll_fout2",0,
+		WIN2030_REG_OFFSET_VI_SHUTTER0, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_1,     "divder_u_vi_shutter_div_dynm_1",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VI_SHUTTER1, 4, 7,  CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_2,     "divder_u_vi_shutter_div_dynm_2",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VI_SHUTTER2, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_3,     "divder_u_vi_shutter_div_dynm_3",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VI_SHUTTER3, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_4,     "divder_u_vi_shutter_div_dynm_4",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VI_SHUTTER4, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VI_SHUTTER_DIV_DYNM_5,     "divder_u_vi_shutter_div_dynm_5",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VI_SHUTTER5, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VO_ACLK_DIV_DYNM,         "divder_u_vo_aclk_div_dynm", "mux_u_vo_aclk_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_VO_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_IESMCLK_DIV_DYNM,       "divder_u_iesmclk_div_dynm",     "fixed_rate_clk_spll0_fout3", 0,
+		WIN2030_REG_OFFSET_VO_IESMCLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VO_PIXEL_DIV_DYNM,	 "divder_u_vo_pixel_div_dynm",	"mux_u_vo_pixel_root_2mux1", 0,
+		WIN2030_REG_OFFSET_VO_PIXEL_CTRL, 4, 6, CLK_DIVIDER_ROUND_CLOSEST, u_6_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VO_MCLK_DIV_DYNM,     "divder_u_vo_mclk_div_dynm",   "clk_apll_fout1", 0,
+		WIN2030_REG_OFFSET_VO_MCLK_CTRL, 4, 8, CLK_DIVIDER_ROUND_CLOSEST, u_8_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VO_CEC_DIV_DYNM,     "divder_u_vo_cec_div_dynm",   "fixed_rate_clk_vpll_fout2", 0,
+		WIN2030_REG_OFFSET_VO_PHY_CLKCTRL, 16, 16, CLK_DIVIDER_ROUND_CLOSEST, u_16_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VC_ACLK_DIV_DYNM,     "divder_u_vc_aclk_div_dynm",   "mux_u_vcaclk_root_2mux1_gfree", 0,
+		WIN2030_REG_OFFSET_VC_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_JD_DIV_DYNM,     "divder_u_jd_div_dynm",   "clk_clk_vc_root", 0,
+		WIN2030_REG_OFFSET_JD_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_JE_DIV_DYNM,     "divder_u_je_div_dynm",   "clk_clk_vc_root", 0,
+		WIN2030_REG_OFFSET_JE_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VE_DIV_DYNM,     "divder_u_ve_div_dynm",   "clk_clk_vc_root", 0,
+		WIN2030_REG_OFFSET_VE_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_VD_DIV_DYNM,     "divder_u_vd_div_dynm",    "clk_clk_vc_root", 0,
+		WIN2030_REG_OFFSET_VD_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_G2D_DIV_DYNM,       "divder_u_g2d_div_dynm",     "clk_clk_dsp_root", 0,
+		WIN2030_REG_OFFSET_G2D_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_AONDMA_AXI_DIV_DYNM,     "divder_u_aondma_axi_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_AON_DMA_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_CRYPTO_DIV_DYNM,     "divder_u_crypto_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		WIN2030_REG_OFFSET_SPACC_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_SATA_PHY_REF_DIV_DYNM,     "divder_u_sata_phy_ref_div_dynm",   "fixed_rate_clk_spll1_fout2", 0,
+		WIN2030_REG_OFFSET_SATA_OOB_CTRL, 0, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_DSP_0_ACLK_DIV_DYNM,     "divder_u_dsp_0_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		WIN2030_REG_OFFSET_DSP_CFG_CTRL, 19, 1, },
+
+	{ WIN2030_DIVDER_U_DSP_1_ACLK_DIV_DYNM,     "divder_u_dsp_1_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		WIN2030_REG_OFFSET_DSP_CFG_CTRL, 20, 1, },
+
+	{ WIN2030_DIVDER_U_DSP_2_ACLK_DIV_DYNM,     "divder_u_dsp_2_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		WIN2030_REG_OFFSET_DSP_CFG_CTRL, 21, 1, },
+
+	{ WIN2030_DIVDER_U_DSP_3_ACLK_DIV_DYNM,     "divder_u_dsp_3_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		WIN2030_REG_OFFSET_DSP_CFG_CTRL, 22, 1, },
+
+	{ WIN2030_DIVDER_U_AON_RTC_DIV_DYNM,     "divder_u_aon_rtc_div_dynm",   "clk_clk_1m", 0,
+		WIN2030_REG_OFFSET_RTC_CLK_CTRL, 21, 11, CLK_DIVIDER_ROUND_CLOSEST, u_11_bit_special_div_table},
+
+	{ WIN2030_DIVDER_U_U84_RTC_TOGGLE_DIV_DYNM,     "divder_u_u84_rtc_toggle_dynm",   "fixed_rate_clk_xtal_24m", 0,
+		WIN2030_REG_OFFSET_RTC_CLK_CTRL, 16, 5, CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ROUND_CLOSEST},
+
+};
+
+/*
+	these clks should init early to cost down the whole clk module init time
+*/
+
+static struct eswin_clock win2030_clks_early_0[] = {
+	{ WIN2030_CLK_CLK_DSP_ROOT , "clk_clk_dsp_root", "mux_u_dsp_aclk_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_VC_ROOT, "clk_clk_vc_root", "mux_u_vcdec_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+};
+
+static struct eswin_clock win2030_clks_early_1[] = {
+	{ WIN2030_CLK_CLK_SYS_CFG	,"clk_clk_sys_cfg", "mux_u_syscfg_clk_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_D2DDR_ACLK	,"clk_clk_d2ddr_aclk", "divder_u_ddr_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_AONDMA_AXI_ST3,"clk_clk_aondma_axi_st3","mux_u_aondma_axi2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_G2D_ST2	,"clk_clk_g2d_st2",	"divder_u_g2d_div_dynm", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_MIPI_TXESC	,"clk_clk_mipi_txesc",	"fixed_factor_u_mipi_txesc_div10", CLK_SET_RATE_PARENT,},
+	{ WIN2030_CLK_CLK_VI_ACLK_ST1	,"clk_clk_vi_aclk_st1",	"divder_u_vi_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+};
+
+static struct eswin_gate_clock win2030_gate_clks[] = {
+
+	{ WIN2030_GATE_CLK_CPU_EXT_SRC_CORE_CLK_0 ,	"gate_clk_cpu_ext_src_core_clk_0", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 28, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_EXT_SRC_CORE_CLK_1 ,	"gate_clk_cpu_ext_src_core_clk_1", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 29, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_EXT_SRC_CORE_CLK_2 ,	"gate_clk_cpu_ext_src_core_clk_2", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_EXT_SRC_CORE_CLK_3 ,	"gate_clk_cpu_ext_src_core_clk_3", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_TRACE_CLK_0 ,		"gate_clk_cpu_trace_clk_0", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 24, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_TRACE_CLK_1 ,		"gate_clk_cpu_trace_clk_1", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 25, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_TRACE_CLK_2 ,		"gate_clk_cpu_trace_clk_2", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 26, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_TRACE_CLK_3 ,		"gate_clk_cpu_trace_clk_3", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 27, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_TRACE_COM_CLK ,		"gate_clk_cpu_trace_com_clk", "mux_u_cpu_aclk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 23, 0, },
+
+	{ WIN2030_GATE_CLK_CPU_CLK ,			"gate_clk_cpu_clk", "mux_u_cpu_aclk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_U84_CLK_CTRL, 28, 0, }, /*same as WIN2030_GATE_CLK_CPU_EXT_SRC_CORE_CLK_0 */
+
+	{ WIN2030_GATE_CLK_SPLL0_FOUT2 ,		"gate_clk_spll0_fout2", "fixed_rate_clk_spll0_fout2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SPLL0_CFG_2, 31, 0, },
+
+	{ WIN2030_GATE_NOC_NSP_CLK ,			"gate_noc_nsp_clk", "divder_u_noc_nsp_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NOC_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_BOOTSPI ,			"gate_clk_bootspi", "mux_u_bootspi_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_BOOTSPI_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_BOOTSPI_CFG	,		"gate_clk_bootspi_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_BOOTSPI_CFGCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_SCPU_CORE	,		"gate_clk_scpu_core",   "mux_u_scpu_core_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SCPU_CORECLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_SCPU_BUS 			,"gate_clk_scpu_bus",   "fixed_factor_u_scpu_bus_div2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SCPU_BUSCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_LPCPU_CORE			,"gate_clk_lpcpu_core",   "mux_u_lpcpu_core_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LPCPU_CORECLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_LPCPU_BUS			,"gate_clk_lpcpu_bus",   "fixed_factor_u_lpcpu_bus_div2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LPCPU_BUSCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_GPU_ACLK 			,"gate_gpu_aclk",   "divder_u_gpu_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_GPU_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_GPU_GRAY_CLK 			,"gate_gpu_gray_clk",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_GPU_GRAY_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_GPU_CFG_CLK			,"gate_gpu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_GPU_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_DSPT_ACLK			,"gate_dspt_aclk",   "divder_u_dsp_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DSP_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_DSPT_CFG_CLK 			,"gate_dspt_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DSP_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_D2D_ACLK 			,"gate_d2d_aclk",   "divder_u_d2d_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_D2D_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_D2D_CFG_CLK			,"gate_d2d_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_D2D_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_TCU_ACLK 			,"gate_tcu_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TCU_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_TCU_CFG_CLK			,"gate_tcu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TCU_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_DDRT_CFG_CLK			,"gate_ddrt_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 9, 0, },
+
+	{ WIN2030_GATE_DDRT0_P0_ACLK			,"gate_ddrt0_p0_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 4, 0, },
+
+	{ WIN2030_GATE_DDRT0_P1_ACLK			,"gate_ddrt0_p1_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 5, 0, },
+
+	{ WIN2030_GATE_DDRT0_P2_ACLK			,"gate_ddrt0_p2_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 6, 0, },
+
+	{ WIN2030_GATE_DDRT0_P3_ACLK			,"gate_ddrt0_p3_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 7, 0, },
+
+	{ WIN2030_GATE_DDRT0_P4_ACLK			,"gate_ddrt0_p4_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 8, 0, },
+
+	{ WIN2030_GATE_DDRT1_P0_ACLK			,"gate_ddrt1_p0_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR1_CLK_CTRL, 4, 0, },
+
+	{ WIN2030_GATE_DDRT1_P1_ACLK			,"gate_ddrt1_p1_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR1_CLK_CTRL, 5, 0, },
+
+	{ WIN2030_GATE_DDRT1_P2_ACLK			,"gate_ddrt1_p2_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR1_CLK_CTRL, 6, 0, },
+
+	{ WIN2030_GATE_DDRT1_P3_ACLK			,"gate_ddrt1_p3_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR1_CLK_CTRL, 7, 0, },
+
+	{ WIN2030_GATE_DDRT1_P4_ACLK			,"gate_ddrt1_p4_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR1_CLK_CTRL, 8, 0, },
+
+	{ WIN2030_GATE_CLK_HSP_ACLK			,"gate_clk_hsp_aclk",   "divder_u_hsp_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_HSP_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_HSP_CFGCLK			,"gate_clk_hsp_cfgclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_HSP_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_PCIET_ACLK			,"gate_pciet_aclk",   "divder_u_pcie_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_PCIE_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_PCIET_CFG_CLK			,"gate_pciet_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_PCIE_CFG_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_PCIET_CR_CLK 			,"gate_pciet_cr_clk",   "fixed_factor_u_pcie_cr_div2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_PCIE_CFG_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_PCIET_AUX_CLK			,"gate_pciet_aux_clk",   "fixed_factor_u_pcie_aux_div4", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_PCIE_CFG_CTRL, 1, 0, },
+
+	{ WIN2030_GATE_NPU_ACLK 			,"gate_npu_aclk",   "divder_u_npu_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NPU_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_NPU_CFG_CLK			,"gate_npu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NPU_ACLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_NPU_LLC_ACLK 			,"gate_npu_llc_aclk",   "mux_u_npu_llclk_3mux1_gfree", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NPU_LLC_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_NPU_CLK				,"gate_npu_clk",   "divder_u_npu_coreclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NPU_CORE_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_NPU_E31_CLK			,"gate_npu_e31_clk",   "divder_u_npu_e31_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_NPU_CORE_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_VI_ACLK				,"gate_vi_aclk",   "clk_clk_vi_aclk_st1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VI_CFG_CLK			,"gate_vi_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_ACLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_VI_DIG_DW_CLK			,"gate_vi_dig_dw_clk",   "divder_u_vi_dw_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_DWCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VI_DVP_CLK			,"gate_vi_dvp_clk",   "divder_u_vi_dvp_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_DVP_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VI_DIG_ISP_CLK			,"gate_vi_dig_isp_clk",   "divder_u_vi_dig_isp_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_DIG_ISP_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_0			,"gate_vi_shutter_0",   "divder_u_vi_shutter_div_dynm_0", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER0, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_1			,"gate_vi_shutter_1",   "divder_u_vi_shutter_div_dynm_1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER1, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_2			,"gate_vi_shutter_2",   "divder_u_vi_shutter_div_dynm_2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER2, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_3			,"gate_vi_shutter_3",   "divder_u_vi_shutter_div_dynm_3", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER3, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_4			,"gate_vi_shutter_4",   "divder_u_vi_shutter_div_dynm_4", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER4, 31, 0, },
+
+	{ WIN2030_GATE_VI_SHUTTER_5			,"gate_vi_shutter_5",   "divder_u_vi_shutter_div_dynm_5", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_SHUTTER5, 31, 0, },
+
+	{ WIN2030_GATE_VI_PHY_TXCLKESC			,"gate_vi_phy_txclkesc",   "clk_clk_mipi_txesc", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_PHY_CLKCTRL, 0, 0, },
+
+	{ WIN2030_GATE_VI_PHY_CFG			,"gate_vi_phy_cfg",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VI_PHY_CLKCTRL, 1, 0, },
+
+	{ WIN2030_GATE_VO_ACLK				,"gate_vo_aclk",   "divder_u_vo_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VO_CFG_CLK			,"gate_vo_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_ACLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_VO_HDMI_IESMCLK			,"gate_vo_hdmi_iesmclk",   "divder_u_iesmclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_IESMCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VO_PIXEL_CLK 			,"gate_vo_pixel_clk",   "divder_u_vo_pixel_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_PIXEL_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VO_I2S_MCLK			,"gate_vo_i2s_mclk",   "mux_u_vo_mclk_2mux_ext_mclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_MCLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VO_CR_CLK			,"gate_vo_cr_clk",   "clk_clk_mipi_txesc", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VO_PHY_CLKCTRL, 1, 0, },
+
+	{ WIN2030_GATE_VC_ACLK				,"gate_vc_aclk",   "divder_u_vc_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_ACLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VC_CFG_CLK			,"gate_vc_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_VC_JE_CLK			,"gate_vc_je_clk",   "divder_u_je_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_JE_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VC_JD_CLK			,"gate_vc_jd_clk",   "divder_u_jd_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_JD_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VC_VE_CLK			,"gate_vc_ve_clk",   "divder_u_ve_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VE_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_VC_VD_CLK			,"gate_vc_vd_clk",   "divder_u_vd_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VD_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_G2D_CFG_CLK			,"gate_g2d_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_G2D_CTRL, 28, 0, },
+
+	{ WIN2030_GATE_G2D_CLK				,"gate_g2d_clk",   "clk_clk_g2d_st2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_G2D_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_G2D_ACLK 			,"gate_g2d_aclk",   "clk_clk_g2d_st2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_G2D_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_AONDMA_CFG			,"gate_clk_aondma_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_AON_DMA_CLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_AONDMA_ACLK			,"gate_aondma_aclk",   "clk_clk_aondma_axi_st3", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_AON_DMA_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_AON_ACLK 			,"gate_aon_aclk",   "clk_clk_aondma_axi_st3", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_AON_DMA_CLK_CTRL, 29, 0, },
+
+	{ WIN2030_GATE_TIMER_CLK_0 			,"gate_time_clk_0",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_TIMER_CLK_1 			,"gate_time_clk_1",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 1, 0, },
+
+	{ WIN2030_GATE_TIMER_CLK_2 			,"gate_time_clk_2",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 2, 0, },
+
+	{ WIN2030_GATE_TIMER_CLK_3 			,"gate_time_clk_3",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 3, 0, },
+
+	{ WIN2030_GATE_TIMER_PCLK_0			,"gate_timer_pclk_0",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 4, 0, },
+
+	{ WIN2030_GATE_TIMER_PCLK_1			,"gate_timer_pclk_1",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 5, 0, },
+
+	{ WIN2030_GATE_TIMER_PCLK_2			,"gate_timer_pclk_2",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 6, 0, },
+
+	{ WIN2030_GATE_TIMER_PCLK_3			,"gate_timer_pclk_3",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 7, 0, },
+
+	{ WIN2030_GATE_TIMER3_CLK8			,"gate_timer3_clk8",   "fixed_rate_clk_vpll_fout3", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TIMER_CLK_CTRL, 8, 0, },
+
+	{ WIN2030_GATE_CLK_RTC_CFG			,"gate_clk_rtc_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_RTC_CLK_CTRL, 2, 0, },
+
+	{ WIN2030_GATE_CLK_RTC				,"gate_clk_rtc",   "divder_u_aon_rtc_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_RTC_CLK_CTRL, 1, 0, },
+
+	{ WIN2030_GATE_CLK_PKA_CFG			,"gate_clk_pka_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_PKA_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_SPACC_CFG			,"gate_clk_spacc_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SPACC_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_CRYPTO			,"gate_clk_crypto",   "divder_u_crypto_div_dynm", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SPACC_CLK_CTRL, 30, 0, },
+
+	{ WIN2030_GATE_CLK_TRNG_CFG 			,"gate_clk_trng_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_TRNG_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_OTP_CFG			,"gate_clk_otp_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_OTP_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_0			,"gate_clk_mailbox_0",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 0, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_1			,"gate_clk_mailbox_1",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 1, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_2			,"gate_clk_mailbox_2",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 2, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_3			,"gate_clk_mailbox_3",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 3, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_4			,"gate_clk_mailbox_4",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 4, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_5			,"gate_clk_mailbox_5",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 5, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_6			,"gate_clk_mailbox_6",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 6, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_7			,"gate_clk_mailbox_7",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 7, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_8			,"gate_clk_mailbox_8",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 8, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_9			,"gate_clk_mailbox_9",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 9, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_10			,"gate_clk_mailbox_10",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 10, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_11			,"gate_clk_mailbox_11",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 11, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_12			,"gate_clk_mailbox_12",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 12, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_13			,"gate_clk_mailbox_13",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 13, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_14			,"gate_clk_mailbox_14",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 14, 0, },
+
+	{ WIN2030_GATE_CLK_MAILBOX_15			,"gate_clk_mailbox_15",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 15, 0, },
+
+	{ WIN2030_GATE_LSP_I2C0_PCLK			,"gate_i2c0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 7, 0, },
+
+	{ WIN2030_GATE_LSP_I2C1_PCLK			,"gate_i2c1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 8, 0, },
+
+	{ WIN2030_GATE_LSP_I2C2_PCLK			,"gate_i2c2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 9, 0, },
+
+	{ WIN2030_GATE_LSP_I2C3_PCLK			,"gate_i2c3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 10, 0, },
+
+	{ WIN2030_GATE_LSP_I2C4_PCLK			,"gate_i2c4_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 11, 0, },
+
+	{ WIN2030_GATE_LSP_I2C5_PCLK			,"gate_i2c5_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 12, 0, },
+
+	{ WIN2030_GATE_LSP_I2C6_PCLK			,"gate_i2c6_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 13, 0, },
+
+	{ WIN2030_GATE_LSP_I2C7_PCLK			,"gate_i2c7_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 14, 0, },
+
+	{ WIN2030_GATE_LSP_I2C8_PCLK			,"gate_i2c8_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 15, 0, },
+
+	{ WIN2030_GATE_LSP_I2C9_PCLK			,"gate_i2c9_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 16, 0, },
+
+	{ WIN2030_GATE_LSP_WDT0_PCLK			,"gate_lsp_wdt0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 28, 0, },
+
+	{ WIN2030_GATE_LSP_WDT1_PCLK			,"gate_lsp_wdt1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 29, 0, },
+
+	{ WIN2030_GATE_LSP_WDT2_PCLK			,"gate_lsp_wdt2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 30, 0, },
+
+	{ WIN2030_GATE_LSP_WDT3_PCLK			,"gate_lsp_wdt3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 31, 0, },
+
+	{ WIN2030_GATE_LSP_SSI0_PCLK			,"gate_lsp_ssi0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 26, 0, },
+
+	{ WIN2030_GATE_LSP_SSI1_PCLK			,"gate_lsp_ssi1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 27, 0, },
+
+	{ WIN2030_GATE_LSP_UART0_PCLK			,"gate_lsp_uart0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 17, 0, },
+
+	{ WIN2030_GATE_LSP_UART1_PCLK			,"gate_lsp_uart1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 18, 0, },
+
+	{ WIN2030_GATE_LSP_UART2_PCLK			,"gate_lsp_uart2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 19, 0, },
+
+	{ WIN2030_GATE_LSP_UART3_PCLK			,"gate_lsp_uart3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 20, 0, },
+
+	{ WIN2030_GATE_LSP_UART4_PCLK			,"gate_lsp_uart4_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 21, 0, },
+
+	{ WIN2030_GATE_LSP_TIMER_PCLK			,"gate_lsp_timer_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 25, 0, },
+
+	{ WIN2030_GATE_LSP_FAN_PCLK			,"gate_lsp_fan_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 0, 0, },
+
+	{ WIN2030_GATE_LSP_PVT_PCLK			,"gate_lsp_pvt_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN0, 1, 0, },
+
+	{ WIN2030_GATE_LSP_PVT0_CLK			,"gate_pvt0_clk",   "fixed_factor_u_pvt_div20", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 16, 0, },
+
+	{ WIN2030_GATE_LSP_PVT1_CLK			,"gate_pvt1_clk",   "fixed_factor_u_pvt_div20", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_LSP_CLK_EN1, 17, 0, },
+
+	{ WIN2030_GATE_VC_JE_PCLK			,"gate_vc_je_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 2, 0, },
+
+	{ WIN2030_GATE_VC_JD_PCLK			,"gate_vc_jd_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 1, 0, },
+
+	{ WIN2030_GATE_VC_VE_PCLK			,"gate_vc_ve_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 5, 0, },
+
+	{ WIN2030_GATE_VC_VD_PCLK			,"gate_vc_vd_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 4, 0, },
+
+	{ WIN2030_GATE_VC_MON_PCLK			,"gate_vc_mon_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_VC_CLKEN_CTRL, 3, 0, },
+
+	{ WIN2030_GATE_HSP_MSHC0_CORE_CLK		,"gate_hsp_mshc0_core_clk",   "divder_u_mshc_core_div_dynm_0", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_MSHC0_CORECLK_CTRL, 16, 0, },
+
+	{ WIN2030_GATE_HSP_MSHC1_CORE_CLK		,"gate_hsp_mshc1_core_clk",   "divder_u_mshc_core_div_dynm_1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_MSHC1_CORECLK_CTRL, 16, 0, },
+
+	{ WIN2030_GATE_HSP_MSHC2_CORE_CLK		,"gate_hsp_mshc2_core_clk",   "divder_u_mshc_core_div_dynm_2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_MSHC2_CORECLK_CTRL, 16, 0, },
+
+	{ WIN2030_GATE_HSP_SATA_RBC_CLK			,"gate_hsp_sata_rbc_clk",   "fixed_rate_clk_spll1_fout2", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SATA_RBC_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_HSP_SATA_OOB_CLK			,"gate_hsp_sata_oob_clk",   "mux_u_sata_phy_2mux1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_SATA_OOB_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_HSP_DMA0_CLK			,"gate_hsp_dma0_clk",   "gate_clk_hsp_aclk", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_HSP_ACLK_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_HSP_ETH0_CORE_CLK		,"gate_hsp_eth0_core_clk",   "divder_u_eth_txclk_div_dynm_0", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_ETH0_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_HSP_ETH1_CORE_CLK		,"gate_hsp_eth1_core_clk",   "divder_u_eth_txclk_div_dynm_1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_ETH1_CTRL, 0, 0, },
+
+	{ WIN2030_GATE_HSP_RMII_REF_0			,"gate_hsp_rmii_ref_0",   "mux_u_rmii_ref_2mux1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_ETH0_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_HSP_RMII_REF_1			,"gate_hsp_rmii_ref_1",   "mux_u_rmii_ref_2mux1", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_ETH1_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_AON_I2C0_PCLK			,"gate_aon_i2c0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_I2C0_CLK_CTRL, 31, 0, },
+
+	{ WIN2030_GATE_AON_I2C1_PCLK			,"gate_aon_i2c1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_I2C1_CLK_CTRL, 31, 0, },
+
+	/*
+	{ WIN2030_GATE_CLK_DDR_PLL_BYP_CLK			,"gate_clk_ddr_pll_byp_clk", "fixed_rate_pll_ddr", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 3, 0, },
+
+	{ WIN2030_GATE_CLK_DDR_RX_TEST_CLK			,"gate_clk_ddr_rx_test_clk", "fixed_rate_pll_ddr", CLK_SET_RATE_PARENT,
+		WIN2030_REG_OFFSET_DDR_CLK_CTRL, 1, 0, },
+	*/
+
+};
+
+/* win2030 clocks */
+static struct eswin_clock win2030_clks[] = {
+	{  WIN2030_CLK_CPU_EXT_SRC_CORE_CLK_0	,"clk_cpu_ext_src_core_clk_0",	"gate_clk_cpu_ext_src_core_clk_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_EXT_SRC_CORE_CLK_1	,"clk_cpu_ext_src_core_clk_1",	"gate_clk_cpu_ext_src_core_clk_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_EXT_SRC_CORE_CLK_2	,"clk_cpu_ext_src_core_clk_2",	"gate_clk_cpu_ext_src_core_clk_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_EXT_SRC_CORE_CLK_3	,"clk_cpu_ext_src_core_clk_3",	"gate_clk_cpu_ext_src_core_clk_3", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_TRACE_CLK_0		,"clk_cpu_trace_clk_0",	 	"gate_clk_cpu_trace_clk_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_TRACE_CLK_1		,"clk_cpu_trace_clk_1",	 	"gate_clk_cpu_trace_clk_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_TRACE_CLK_2		,"clk_cpu_trace_clk_2",	 	"gate_clk_cpu_trace_clk_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_TRACE_CLK_3		,"clk_cpu_trace_clk_3",	 	"gate_clk_cpu_trace_clk_3", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_CPU_TRACE_COM_CLK 	,"clk_cpu_trace_com_clk",	"gate_clk_cpu_trace_com_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CPU_CLK			,"clk_cpu_clk",			"gate_clk_cpu_clk", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_CLK_1M			,"clk_clk_1m",			"fixed_factor_u_clk_1m_div24", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NOC_CFG_CLK		,"clk_noc_cfg_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NOC_NSP_CLK		,"clk_noc_nsp_clk",		"gate_noc_nsp_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_BOOTSPI		,"clk_clk_bootspi",		"gate_clk_bootspi", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_BOOTSPI_CFG		,"clk_clk_bootspi_cfg",		"gate_clk_bootspi_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_U84_CORE_LP		,"clk_clk_u84_core_lp",		"fixed_factor_u_u84_core_lp_div2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_SCPU_CORE		,"clk_clk_scpu_core",		"gate_clk_scpu_core", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_SCPU_BUS 		,"clk_clk_scpu_bus",		"gate_clk_scpu_bus", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_LPCPU_CORE		,"clk_clk_lpcpu_core",		"gate_clk_lpcpu_core", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_LPCPU_BUS		,"clk_clk_lpcpu_bus",		"gate_clk_lpcpu_bus", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_GPU_ACLK 		,"clk_gpu_aclk",		"gate_gpu_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_GPU_GRAY_CLK 		,"clk_gpu_gray_clk",		"gate_gpu_gray_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_GPU_CFG_CLK		,"clk_gpu_cfg_clk",		"gate_gpu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DSPT_ACLK		,"clk_dspt_aclk",		"gate_dspt_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DSPT_CFG_CLK 		,"clk_dspt_cfg_clk",		"gate_dspt_cfg_clk", CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,},
+	{  WIN2030_CLK_D2D_ACLK 		,"clk_d2d_aclk",		"gate_d2d_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_D2D_CFG_CLK		,"clk_d2d_cfg_clk",	 	"gate_d2d_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TCU_ACLK 		,"clk_tcu_aclk",		"gate_tcu_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TCU_CFG_CLK		,"clk_tcu_cfg_clk",		"gate_tcu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT_CFG_CLK 		,"clk_ddrt_cfg_clk",		"gate_ddrt_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT0_P0_ACLK		,"clk_ddrt0_p0_aclk",		"gate_ddrt0_p0_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT0_P1_ACLK		,"clk_ddrt0_p1_aclk",		"gate_ddrt0_p1_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT0_P2_ACLK		,"clk_ddrt0_p2_aclk",		"gate_ddrt0_p2_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT0_P3_ACLK		,"clk_ddrt0_p3_aclk",		"gate_ddrt0_p3_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT0_P4_ACLK		,"clk_ddrt0_p4_aclk",		"gate_ddrt0_p4_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT1_P0_ACLK		,"clk_ddrt1_p0_aclk",		"gate_ddrt1_p0_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT1_P1_ACLK		,"clk_ddrt1_p1_aclk",		"gate_ddrt1_p1_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT1_P2_ACLK		,"clk_ddrt1_p2_aclk",		"gate_ddrt1_p2_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT1_P3_ACLK		,"clk_ddrt1_p3_aclk",		"gate_ddrt1_p3_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDRT1_P4_ACLK		,"clk_ddrt1_p4_aclk",		"gate_ddrt1_p4_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_ACLK 		,"clk_hsp_aclk",		"gate_clk_hsp_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_CFG_CLK		,"clk_hsp_cfg_clk",		"gate_clk_hsp_cfgclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_SATA_RBC_CLK 	,"clk_hsp_sata_rbc_clk",	"gate_hsp_sata_rbc_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_SATA_OOB_CLK 	,"clk_hsp_sata_oob_clk",	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_SATA_PHY_REF		,"clk_hsp_sata_phy_ref",	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_SATA_PMALIVE_CLK 	,"clk_hsp_sata_pmalive_clk",  	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_ETH_APP_CLK		,"clk_hsp_eth_app_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_ETH_CSR_CLK		,"clk_hsp_eth_csr_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_ETH0_CORE_CLK	,"clk_hsp_eth0_core_clk",	"gate_hsp_eth0_core_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_ETH1_CORE_CLK	,"clk_hsp_eth1_core_clk",	"gate_hsp_eth1_core_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC0_CORE_CLK	,"clk_hsp_mshc0_core_clk",	"gate_hsp_mshc0_core_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC1_CORE_CLK	,"clk_hsp_mshc1_core_clk",	"gate_hsp_mshc1_core_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC2_CORE_CLK	,"clk_hsp_mshc2_core_clk",	"gate_hsp_mshc2_core_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC0_TMR_CLK	,"clk_hsp_mshc0_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC1_TMR_CLK	,"clk_hsp_mshc1_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_MSHC2_TMR_CLK	,"clk_hsp_mshc2_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_USB0_SUSPEND_CLK 	,"clk_hsp_usb0_suspend_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_USB1_SUSPEND_CLK 	,"clk_hsp_usb1_suspend_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PCIET_ACLK		,"clk_pciet_aclk",		"gate_pciet_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PCIET_CFG_CLK		,"clk_pciet_cfg_clk",		"gate_pciet_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PCIET_CR_CLK 		,"clk_pciet_cr_clk",		"gate_pciet_cr_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PCIET_AUX_CLK		,"clk_pciet_aux_clk",		"gate_pciet_aux_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NPU_ACLK 		,"clk_npu_aclk",		"gate_npu_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NPU_CFG_CLK		,"clk_npu_cfg_clk",		"gate_npu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_NPU_LLC_SRC0 	,"clk_clk_npu_llc_src0",	"divder_u_npu_llc_src0_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_NPU_LLC_SRC1 	,"clk_clk_npu_llc_src1",	"divder_u_npu_llc_src1_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NPU_LLC_ACLK 		,"clk_npu_llc_aclk",		"gate_npu_llc_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NPU_CLK			,"clk_npu_clk",			"gate_npu_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_NPU_E31_CLK		,"clk_npu_e31_clk",		"gate_npu_e31_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_ACLK			,"clk_vi_aclk",			"gate_vi_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_DIG_DW_CLK		,"clk_vi_dig_dw_clk",		"gate_vi_dig_dw_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_CFG_CLK		,"clk_vi_cfg_clk",		"gate_vi_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_DVP_CLK		,"clk_vi_dvp_clk",		"gate_vi_dvp_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_DIG_ISP_CLK		,"clk_vi_dig_isp_clk",		"gate_vi_dig_isp_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_0 		,"clk_vi_shutter_0",		"gate_vi_shutter_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_1 		,"clk_vi_shutter_1",		"gate_vi_shutter_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_2 		,"clk_vi_shutter_2",		"gate_vi_shutter_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_3 		,"clk_vi_shutter_3",		"gate_vi_shutter_3", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_4 		,"clk_vi_shutter_4",		"gate_vi_shutter_4", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_SHUTTER_5 		,"clk_vi_shutter_5",		"gate_vi_shutter_5", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_PHY_TXCLKESC		,"clk_vi_phy_txclkesc",		"gate_vi_phy_txclkesc", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VI_PHY_CFG		,"clk_vi_phy_cfg",		"gate_vi_phy_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_ACLK			,"clk_vo_aclk",			"gate_vo_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_CFG_CLK		,"clk_vo_cfg_clk",		"gate_vo_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_HDMI_IESMCLK		,"clk_vo_hdmi_iesmclk",		"gate_vo_hdmi_iesmclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_PIXEL_CLK 		,"clk_vo_pixel_clk",		"gate_vo_pixel_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_I2S_MCLK		,"clk_vo_i2s_mclk",		"gate_vo_i2s_mclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_CR_CLK		,"clk_vo_cr_clk",		"gate_vo_cr_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VO_CEC_CLK		,"clk_vo_cec_clk",		"divder_u_vo_cec_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_ACLK			,"clk_vc_aclk",			"gate_vc_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_CFG_CLK		,"clk_vc_cfg_clk",		"gate_vc_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_JE_CLK		,"clk_vc_je_clk",		"gate_vc_je_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_JD_CLK		,"clk_vc_jd_clk",		"gate_vc_jd_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_VE_CLK		,"clk_vc_ve_clk",		"gate_vc_ve_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_VD_CLK		,"clk_vc_vd_clk",		"gate_vc_vd_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_G2D_CFG_CLK		,"clk_g2d_cfg_clk",		"gate_g2d_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_G2D_CLK			,"clk_g2d_clk",			"gate_g2d_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_G2D_ACLK 		,"clk_g2d_aclk",		"gate_g2d_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_AONDMA_CFG		,"clk_aondma_cfg",		"gate_clk_aondma_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_AONDMA_ACLK		,"clk_aondma_aclk",		"gate_aondma_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_AON_ACLK 		,"clk_aon_aclk",		"gate_aon_aclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_CLK_0 		,"clk_timer_clk_0",		"gate_time_clk_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_CLK_1 		,"clk_timer_clk_1",		"gate_time_clk_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_CLK_2 		,"clk_timer_clk_2",		"gate_time_clk_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_CLK_3 		,"clk_timer_clk_3",		"gate_time_clk_3", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_PCLK_0		,"clk_timer_pclk_0",		"gate_timer_pclk_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_PCLK_1		,"clk_timer_pclk_1",		"gate_timer_pclk_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_PCLK_2		,"clk_timer_pclk_2",		"gate_timer_pclk_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER_PCLK_3		,"clk_timer_pclk_3",		"gate_timer_pclk_3", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_TIMER3_CLK8		,"clk_timer3_clk8",		"gate_timer3_clk8", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_RTC_CFG		,"clk_clk_rtc_cfg",		"gate_clk_rtc_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_RTC			,"clk_clk_rtc",			"gate_clk_rtc", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_PKA_CFG		,"clk_clk_pka_cfg",	 	"gate_clk_pka_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_SPACC_CFG		,"clk_clk_spacc_cfg",		"gate_clk_spacc_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_CRYPTO		,"clk_clk_crypto",		"gate_clk_crypto", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_TRNG_CFG 		,"clk_clk_trng_cfg",		"gate_clk_trng_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_OTP_CFG		,"clk_clk_otp_cfg",	 	"gate_clk_otp_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLMM_CFG_CLK 		,"clk_clmm_cfg_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLMM_DEB_CLK 		,"clk_clmm_deb_clk",		"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_0 		,"clk_mailbox0",		"gate_clk_mailbox_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_1 		,"clk_mailbox1",		"gate_clk_mailbox_1", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_2 		,"clk_mailbox2",		"gate_clk_mailbox_2", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_3 		,"clk_mailbox3",		"gate_clk_mailbox_3", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_4 		,"clk_mailbox4",		"gate_clk_mailbox_4", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_5 		,"clk_mailbox5",		"gate_clk_mailbox_5", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_6 		,"clk_mailbox6",		"gate_clk_mailbox_6", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_7 		,"clk_mailbox7",		"gate_clk_mailbox_7", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_8 		,"clk_mailbox8",		"gate_clk_mailbox_8", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_9 		,"clk_mailbox9",		"gate_clk_mailbox_9", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_10 		,"clk_mailbox10",		"gate_clk_mailbox_10", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_11 		,"clk_mailbox11",		"gate_clk_mailbox_11", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_12 		,"clk_mailbox12",		"gate_clk_mailbox_12", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_13 		,"clk_mailbox13",		"gate_clk_mailbox_13", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_14 		,"clk_mailbox14",		"gate_clk_mailbox_14", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_MAILBOX_15 		,"clk_mailbox15",		"gate_clk_mailbox_15", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C0_PCLK		,"clk_i2c0_pclk",		"gate_i2c0_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C1_PCLK		,"clk_i2c1_pclk",		"gate_i2c1_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C2_PCLK		,"clk_i2c2_pclk",		"gate_i2c2_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C3_PCLK		,"clk_i2c3_pclk",		"gate_i2c3_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C4_PCLK		,"clk_i2c4_pclk",		"gate_i2c4_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C5_PCLK		,"clk_i2c5_pclk",		"gate_i2c5_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C6_PCLK		,"clk_i2c6_pclk",		"gate_i2c6_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C7_PCLK		,"clk_i2c7_pclk",		"gate_i2c7_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C8_PCLK		,"clk_i2c8_pclk",		"gate_i2c8_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_I2C9_PCLK		,"clk_i2c9_pclk",		"gate_i2c9_pclk", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_LSP_WDT0_PCLK		,"clk_lsp_wdt0_pclk",		"gate_lsp_wdt0_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_WDT1_PCLK		,"clk_lsp_wdt1_pclk",		"gate_lsp_wdt1_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_WDT2_PCLK		,"clk_lsp_wdt2_pclk",		"gate_lsp_wdt2_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_WDT3_PCLK		,"clk_lsp_wdt3_pclk",		"gate_lsp_wdt3_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_SSI0_PCLK		,"clk_lsp_ssi0_pclk",		"gate_lsp_ssi0_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_SSI1_PCLK		,"clk_lsp_ssi1_pclk",		"gate_lsp_ssi1_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_UART0_PCLK		,"clk_lsp_uart0_pclk",		"gate_lsp_uart0_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_UART1_PCLK		,"clk_lsp_uart1_pclk",		"gate_lsp_uart1_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_UART2_PCLK		,"clk_lsp_uart2_pclk",		"gate_lsp_uart2_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_UART3_PCLK		,"clk_lsp_uart3_pclk",		"gate_lsp_uart3_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_UART4_PCLK		,"clk_lsp_uart4_pclk",		"gate_lsp_uart4_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_TIMER_PCLK		,"clk_lsp_timer_pclk",		"gate_lsp_timer_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_FAN_PCLK		,"clk_lsp_fan_pclk",		"gate_lsp_fan_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_LSP_PVT_PCLK		,"clk_lsp_pvt_pclk",		"gate_lsp_pvt_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PVT_CLK_0		,"clk_pvt0_clk",		"gate_pvt0_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_PVT_CLK_1		,"clk_pvt1_clk",		"gate_pvt1_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_JE_PCLK		,"clk_vc_je_pclk",		"gate_vc_je_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_JD_PCLK		,"clk_vc_jd_pclk",		"gate_vc_jd_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_VE_PCLK		,"clk_vc_ve_pclk",		"gate_vc_ve_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_VD_PCLK		,"clk_vc_vd_pclk",		"gate_vc_vd_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_VC_MON_PCLK		,"clk_vc_mon_pclk",		"gate_vc_mon_pclk", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_HSP_DMA0_CLK		,"clk_hsp_dma0_clk",		"gate_hsp_dma0_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_RMII_REF_0		,"clk_hsp_rmii_ref_0",		"gate_hsp_rmii_ref_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_HSP_RMII_REF_1		,"clk_hsp_rmii_ref_1",		"gate_hsp_rmii_ref_1", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_DSP_ACLK_0		,"clk_dsp_aclk_0",	"divder_u_dsp_0_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DSP_ACLK_1		,"clk_dsp_aclk_1",	"divder_u_dsp_1_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DSP_ACLK_2		,"clk_dsp_aclk_2",	"divder_u_dsp_2_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DSP_ACLK_3		,"clk_dsp_aclk_3",	"divder_u_dsp_3_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_CLK_U84_RTC_TOGGLE		,"clk_clk_u84_rtc_toggle",	"divder_u_u84_rtc_toggle_dynm", CLK_SET_RATE_PARENT,},
+
+	{  WIN2030_CLK_AON_I2C0_PCLK		,"clk_aon_i2c0_pclk",	"gate_aon_i2c0_pclk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_AON_I2C1_PCLK		,"clk_aon_i2c1_pclk",	"gate_aon_i2c1_pclk", CLK_SET_RATE_PARENT,},
+
+	/*
+	{  WIN2030_CLK_DDR_PLL_BYP_CLK 		,"clk_ddr_pll_byp_clk",   "gate_clk_ddr_pll_byp_clk", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDR_PLL_REF_AND_DFI_CLK 	,"clk_ddr_pll_ref_and_dfi_clk",   "mux_u_ddr_2mux1_0", CLK_SET_RATE_PARENT,},
+	{  WIN2030_CLK_DDR_RX_TEST_CLK 		,"clk_ddr_pll_rx_test_clk",   "fixed_rate_pll_ddr", CLK_SET_RATE_PARENT,},
+	*/
+};
+
+#if 0
+static void zebu_stop(void)
+{
+	void __iomem *base = ioremap(0x51810000, 0x1000);
+
+	writel_relaxed(0x8000, base + 0x668);
+}
+#endif
+
+static void special_div_table_init(struct clk_div_table *table, int table_size)
+{
+	int i;
+
+	if (table_size < 3) {
+		return;
+	}
+	if (!table) {
+		return;
+	}
+	/*The hardware decides vaule 0, 1 and 2 both means 2 divsor*/
+	for (i = 0; i < 3; i++) {
+		table[i].val = i;
+		table[i].div = 2;
+	}
+	for (i = 3; i < table_size; i++) {
+		table[i].val = i;
+		table[i].div = i;
+	}
+	return;
+}
+
+static int eswin_clk_probe(struct platform_device *pdev)
+{
+	struct eswin_clock_data *clk_data;
+
+	clk_data = eswin_clk_init(pdev, WIN2030_NR_CLKS);
+	if (!clk_data)
+		return -EAGAIN;
+
+	special_div_table_init(u_3_bit_special_div_table, ARRAY_SIZE(u_3_bit_special_div_table));
+	special_div_table_init(u_4_bit_special_div_table, ARRAY_SIZE(u_4_bit_special_div_table));
+	special_div_table_init(u_6_bit_special_div_table, ARRAY_SIZE(u_6_bit_special_div_table));
+	special_div_table_init(u_7_bit_special_div_table, ARRAY_SIZE(u_7_bit_special_div_table));
+	special_div_table_init(u_8_bit_special_div_table, ARRAY_SIZE(u_8_bit_special_div_table));
+	special_div_table_init(u_11_bit_special_div_table, ARRAY_SIZE(u_11_bit_special_div_table));
+	special_div_table_init(u_16_bit_special_div_table, ARRAY_SIZE(u_16_bit_special_div_table));
+
+	eswin_clk_register_fixed_rate(win2030_fixed_rate_clks,
+				ARRAY_SIZE(win2030_fixed_rate_clks),
+				clk_data);
+	eswin_clk_register_pll(win2030_pll_clks,
+			ARRAY_SIZE(win2030_pll_clks), clk_data, &pdev->dev);
+
+	eswin_clk_register_fixed_factor(win2030_fixed_factor_clks,
+				ARRAY_SIZE(win2030_fixed_factor_clks),
+				clk_data);
+	eswin_clk_register_mux(win2030_mux_clks, ARRAY_SIZE(win2030_mux_clks),
+				clk_data);
+	eswin_clk_register_clk(win2030_clks_early_0, ARRAY_SIZE(win2030_clks_early_0),
+				clk_data);
+	eswin_clk_register_divider(win2030_div_clks, ARRAY_SIZE(win2030_div_clks),
+				clk_data);
+	//zebu_stop();
+	eswin_clk_register_clk(win2030_clks_early_1, ARRAY_SIZE(win2030_clks_early_1),
+				clk_data);
+	eswin_clk_register_gate(win2030_gate_clks, ARRAY_SIZE(win2030_gate_clks),
+				clk_data);
+	eswin_clk_register_clk(win2030_clks, ARRAY_SIZE(win2030_clks), clk_data);
+	return 0;
+}
+
+static const struct of_device_id eswin_clock_dt_ids[] = {
+	 { .compatible = "eswin,win2030-clock", },
+	 { /* sentinel */ },
+};
+
+static struct platform_driver eswin_clock_driver = {
+	.probe	= eswin_clk_probe,
+	.driver = {
+		.name	= "eswin-clock",
+		.of_match_table	= eswin_clock_dt_ids,
+	},
+};
+static int __init win2030_clk_init(void)
+{
+	return platform_driver_register(&eswin_clock_driver);
+}
+arch_initcall(win2030_clk_init);
--- /dev/null
+++ b/drivers/clk/eswin/clk.c
@@ -0,0 +1,915 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/util_macros.h>
+#include <dt-bindings/clock/win2030-clock.h>
+
+#include "clk.h"
+
+struct clk_hw *eswin_clk_find_parent(struct eswin_clock_data *data, char *parent_name)
+{
+	int i;
+	struct clk *clks;
+
+	for (i = 0; i < data->clk_data.clk_num; i++) {
+		clks = data->clk_data.clks[i];
+		if (NULL == clks) {
+			continue;
+		}
+		if (!strcmp(__clk_get_name(clks), parent_name)) {
+			return __clk_get_hw(clks);
+		}
+	}
+	return NULL;
+}
+
+struct eswin_clock_data *eswin_clk_init(struct platform_device *pdev,
+					     int nr_clks)
+{
+	struct eswin_clock_data *clk_data;
+	struct clk **clk_table;
+	void __iomem *base;
+	struct device *parent;
+
+	parent = pdev->dev.parent;
+	if (!parent) {
+		dev_err(&pdev->dev, "no parent\n");
+		goto err;
+	}
+
+	base = of_iomap(parent->of_node, 0);
+	if (!base) {
+		dev_err(&pdev->dev,"failed to map clock registers\n");
+		goto err;
+	}
+	clk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		goto err;
+
+	clk_data->base = base;
+	clk_table = kcalloc(nr_clks, sizeof(*clk_table), GFP_KERNEL);
+	if (!clk_table)
+		goto err_data;
+
+	clk_data->clk_data.clks = clk_table;
+	clk_data->clk_data.clk_num = nr_clks;
+	clk_data->numa_id = dev_to_node(parent);
+	spin_lock_init(&clk_data->lock);
+
+	of_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get, &clk_data->clk_data);
+	return clk_data;
+
+err_data:
+	kfree(clk_data);
+err:
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(eswin_clk_init);
+
+int eswin_clk_register_fixed_rate(const struct eswin_fixed_rate_clock *clks,
+					 int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name) + 2 * sizeof(char) + sizeof(int),
+			GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+		}
+		clk = clk_register_fixed_rate(NULL, name, clks[i].parent_name,
+				clks[i].flags, clks[i].fixed_rate);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, name);
+			kfree(name);
+			goto err;
+		}
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+	}
+
+	return 0;
+err:
+	while (i--)
+		clk_unregister_fixed_rate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_fixed_rate);
+
+static int eswin_calc_pll(u32 *frac_val, u32 *postdiv1_val,
+				 u32 *fbdiv_val, u32 *refdiv_val, u64 rate,
+				 const struct eswin_clk_pll *clk)
+{
+	int ret = 0;
+
+	switch (clk->id) {
+		case WIN2030_APLL_FOUT1:
+			switch (rate) {
+				case APLL_LOW_FREQ:
+					*frac_val = 10603200;
+					*postdiv1_val = 0;
+					*fbdiv_val = 37;
+					*refdiv_val = 1;
+					break;
+				case APLL_HIGH_FREQ:
+				default:
+					*frac_val = 14092861;
+					*postdiv1_val = 0;
+					*fbdiv_val = 163;
+					*refdiv_val = 1;
+					break;
+			}
+			break;
+		case WIN2030_PLL_CPU:
+			switch (rate) {
+				case CLK_FREQ_1800M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 300;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1700M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 283;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1600M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 266;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1500M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 250;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1300M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 216;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1200M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 200;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1000M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 166;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_900M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 150;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_800M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 133;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_700M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 116;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_600M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 100;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_500M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 83;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_400M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 66;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_200M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 33;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_100M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 16;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1400M:
+				default:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 233;
+					*refdiv_val = 1;
+					break;
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			pr_err("%s %d, Invalid pll set req, rate %lld, clk id %d\n", __func__, __LINE__, rate, clk->id);
+			break;
+	}
+	return ret;
+}
+
+#define to_pll_clk(_hw) container_of(_hw, struct eswin_clk_pll, hw)
+static int clk_pll_set_rate(struct clk_hw *hw,
+			    unsigned long rate,
+			    unsigned long parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	u32 frac_val = 0, postdiv1_val, fbdiv_val, refdiv_val;
+	u32 val;
+	int ret;
+	struct clk *clk_cpu_mux = NULL;
+	struct clk *clk_cpu_lp_pll = NULL;
+	struct clk *clk_cpu_pll = NULL;
+	int try_count = 0;
+	bool lock_flag = false;
+	char clk_cpu_mux_name[50] = {0};
+	char clk_cpu_lp_pll_name[50] = {0};
+	char clk_cpu_pll_name[50] = {0};
+
+	ret = eswin_calc_pll(&frac_val, &postdiv1_val, &fbdiv_val, &refdiv_val, (u64)rate, clk);
+	if (ret) {
+		return ret;
+	}
+
+	/*
+	  we must switch the cpu to other clk before we change the cpu pll
+	*/
+	if (WIN2030_PLL_CPU == clk->id) {
+		if (clk->numa_id < 0) {
+			sprintf(clk_cpu_mux_name, "%s", "mux_u_cpu_root_3mux1_gfree");
+			sprintf(clk_cpu_lp_pll_name, "%s", "clk_clk_u84_core_lp");
+			sprintf(clk_cpu_pll_name, "%s", "clk_pll_cpu");
+		} else {
+			sprintf(clk_cpu_mux_name, "d%d_%s", clk->numa_id, "mux_u_cpu_root_3mux1_gfree");
+			sprintf(clk_cpu_lp_pll_name, "d%d_%s", clk->numa_id, "clk_clk_u84_core_lp");
+			sprintf(clk_cpu_pll_name, "d%d_%s", clk->numa_id, "clk_pll_cpu");
+		}
+
+		clk_cpu_mux = __clk_lookup(clk_cpu_mux_name);
+		if (!clk_cpu_mux) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_mux_name);
+			return -EINVAL;
+		}
+		clk_cpu_lp_pll = __clk_lookup(clk_cpu_lp_pll_name);
+		if (!clk_cpu_lp_pll) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_lp_pll_name);
+			return -EINVAL;
+		}
+		clk_cpu_pll = __clk_lookup(clk_cpu_pll_name);
+		if (!clk_cpu_pll) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_pll_name);
+			return -EINVAL;
+		}
+
+		ret = clk_set_parent(clk_cpu_mux, clk_cpu_lp_pll);
+		if (ret) {
+			pr_err("%s %d, faild to switch %s to %s, ret %d\n",__func__,__LINE__, clk_cpu_mux_name,
+				clk_cpu_lp_pll_name, ret);
+			return -EPERM;
+		}
+	}
+
+	/*first disable pll */
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->pllen_width) - 1) << clk->pllen_shift);
+	val |= 0 << clk->pllen_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->fbdiv_width) - 1) << clk->fbdiv_shift);
+	val &= ~(((1 << clk->refdiv_width) - 1) << clk->refdiv_shift);
+	val |= refdiv_val << clk->refdiv_shift;
+	val |= fbdiv_val << clk->fbdiv_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val &= ~(((1 << clk->frac_width) - 1) << clk->frac_shift);
+	val |= frac_val << clk->frac_shift;
+	writel_relaxed(val, clk->ctrl_reg1);
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val &= ~(((1 << clk->postdiv1_width) - 1) << clk->postdiv1_shift);
+	val |= postdiv1_val << clk->postdiv1_shift;
+	writel_relaxed(val, clk->ctrl_reg2);
+
+	/*at last, enable pll */
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->pllen_width) - 1) << clk->pllen_shift);
+	val |= 1 << clk->pllen_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	/*
+	  usually the pll wil lock in 50us
+	*/
+	do {
+		usleep_range(refdiv_val * 80, refdiv_val * 80 * 2);
+		val = readl_relaxed(clk->status_reg);
+		if (val & 1 << clk->lock_shift) {
+			lock_flag = true;
+			break;
+		}
+	} while (try_count++ < 10);
+
+	if (false == lock_flag) {
+		pr_err("%s %d, faild to lock the cpu pll, cpu will work on low power pll\n",__func__,__LINE__);
+		return -EBUSY;
+	}
+	if (WIN2030_PLL_CPU == clk->id) {
+		ret = clk_set_parent(clk_cpu_mux, clk_cpu_pll);
+		if (ret) {
+			pr_err("%s %d, faild to switch %s to %s, ret %d\n",__func__,__LINE__,
+				clk_cpu_mux_name, clk_cpu_pll_name, ret);
+			return -EPERM;
+		}
+	}
+	return  0;
+}
+
+static unsigned long clk_pll_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	u64 frac_val, fbdiv_val, refdiv_val;
+	u32 postdiv1_val;
+	u32 val;
+	u64 rate;
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val = val >> clk->fbdiv_shift;
+	val &= ((1 << clk->fbdiv_width) - 1);
+	fbdiv_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val = val >> clk->refdiv_shift;
+	val &= ((1 << clk->refdiv_width) - 1);
+	refdiv_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val = val >> clk->frac_shift;
+	val &= ((1 << clk->frac_width) - 1);
+	frac_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val = val >> clk->postdiv1_shift;
+	val &= ((1 << clk->postdiv1_width) - 1);
+	postdiv1_val = val;
+
+	switch (clk->id) {
+		case WIN2030_APLL_FOUT1:
+			switch (frac_val) {
+				case 14092861:
+					rate = APLL_HIGH_FREQ;
+					break;
+				case 10603200:
+					rate = APLL_LOW_FREQ;
+					break;
+				default:
+					pr_err("%s %d, clk id %d, unknow frac_val %llu\n", __func__, __LINE__, clk->id, frac_val);
+					rate = 0;
+					break;
+			}
+			break;
+		case WIN2030_PLL_CPU:
+			switch (fbdiv_val) {
+				case 300:
+					rate = CLK_FREQ_1800M;
+					break;
+				case 283:
+					rate = CLK_FREQ_1700M;
+					break;
+				case 266:
+					rate = CLK_FREQ_1600M;
+					break;
+				case 250:
+					rate = CLK_FREQ_1500M;
+					break;
+				case 216:
+					rate = CLK_FREQ_1300M;
+					break;
+				case 200:
+					rate = CLK_FREQ_1200M;
+					break;
+				case 166:
+					rate = CLK_FREQ_1000M;
+					break;
+				case 150:
+					rate = CLK_FREQ_900M;
+					break;
+				case 133:
+					rate = CLK_FREQ_800M;
+					break;
+				case 116:
+					rate = CLK_FREQ_700M;
+					break;
+				case 100:
+					rate = CLK_FREQ_600M;
+					break;
+				case 83:
+					rate = CLK_FREQ_500M;
+					break;
+				case 66:
+					rate = CLK_FREQ_400M;
+					break;
+				case 33:
+					rate = CLK_FREQ_200M;
+					break;
+				case 16:
+					rate = CLK_FREQ_100M;
+					break;
+				case 233:
+					rate = CLK_FREQ_1400M;
+					break;
+				default:
+					pr_err("%s %d, clk id %d, unknow fbdiv_val %llu\n", __func__, __LINE__, clk->id, fbdiv_val);
+					rate = 0;
+					break;
+			}
+			break;
+		default:
+			pr_err("%s %d, unknow clk id %d\n", __func__, __LINE__, clk->id);
+			rate = 0;
+			break;
+	}
+	return rate;
+}
+
+static long clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	int index;
+	u64 round_rate = 0;
+
+	/*Must be sorted in ascending order*/
+	u64 apll_clk[] = {APLL_LOW_FREQ, APLL_HIGH_FREQ};
+	u64 cpu_pll_clk[] = {CLK_FREQ_100M, CLK_FREQ_200M, CLK_FREQ_400M, CLK_FREQ_500M, CLK_FREQ_600M, CLK_FREQ_700M,
+				CLK_FREQ_800M, CLK_FREQ_900M, CLK_FREQ_1000M, CLK_FREQ_1200M, CLK_FREQ_1300M,
+				CLK_FREQ_1400M, CLK_FREQ_1500M, CLK_FREQ_1600M, CLK_FREQ_1700M, CLK_FREQ_1800M};
+
+	switch (clk->id) {
+		case WIN2030_APLL_FOUT1:
+			index = find_closest(rate, apll_clk, ARRAY_SIZE(apll_clk));
+			round_rate = apll_clk[index];
+			break;
+		case WIN2030_PLL_CPU:
+			index = find_closest(rate, cpu_pll_clk, ARRAY_SIZE(cpu_pll_clk));
+			round_rate = cpu_pll_clk[index];
+			break;
+		default:
+			pr_err("%s %d, unknow clk id %d\n", __func__, __LINE__, clk->id);
+			round_rate = 0;
+			break;
+	}
+	return round_rate;
+}
+
+static const struct clk_ops eswin_clk_pll_ops = {
+	.set_rate = clk_pll_set_rate,
+	.recalc_rate = clk_pll_recalc_rate,
+	.round_rate = clk_pll_round_rate,
+};
+
+void eswin_clk_register_pll(struct eswin_pll_clock *clks,
+		int nums, struct eswin_clock_data *data, struct device *dev)
+{
+	void __iomem *base = data->base;
+	struct eswin_clk_pll *p_clk = NULL;
+	struct clk *clk = NULL;
+	struct clk_init_data init;
+	int i;
+
+	p_clk = devm_kzalloc(dev, sizeof(*p_clk) * nums, GFP_KERNEL);
+
+	if (!p_clk)
+		return;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		const char *parent_name = clks[i].parent_name ? kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL) : NULL;
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			if (parent_name) {
+				sprintf((char *)parent_name, "%s", clks[i].parent_name);
+			}
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			if (parent_name) {
+				sprintf((char *)parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+			}
+		}
+
+		init.name = name;
+		init.flags = 0;
+		init.parent_names = parent_name ? &parent_name : NULL;
+		init.num_parents = parent_name ? 1 : 0;
+		init.ops = &eswin_clk_pll_ops;
+
+		p_clk->id = clks[i].id;
+		p_clk->numa_id = data->numa_id;
+		p_clk->ctrl_reg0 = base + clks[i].ctrl_reg0;
+		p_clk->pllen_shift = clks[i].pllen_shift;
+		p_clk->pllen_width = clks[i].pllen_width;
+		p_clk->refdiv_shift = clks[i].refdiv_shift;
+		p_clk->refdiv_width = clks[i].refdiv_width;
+		p_clk->fbdiv_shift = clks[i].fbdiv_shift;
+		p_clk->fbdiv_width = clks[i].fbdiv_width;
+
+		p_clk->ctrl_reg1 = base + clks[i].ctrl_reg1;
+		p_clk->frac_shift = clks[i].frac_shift;
+		p_clk->frac_width = clks[i].frac_width;
+
+		p_clk->ctrl_reg2 = base + clks[i].ctrl_reg2;
+		p_clk->postdiv1_shift = clks[i].postdiv1_shift;
+		p_clk->postdiv1_width = clks[i].postdiv1_width;
+		p_clk->postdiv2_shift = clks[i].postdiv2_shift;
+		p_clk->postdiv2_width = clks[i].postdiv2_width;
+
+		p_clk->status_reg = base + clks[i].status_reg;
+		p_clk->lock_shift = clks[i].lock_shift;
+		p_clk->lock_width = clks[i].lock_width;
+
+		p_clk->hw.init = &init;
+
+		clk = clk_register(dev, &p_clk->hw);
+		if (IS_ERR(clk)) {
+			devm_kfree(dev, p_clk);
+			dev_err(dev, "%s: failed to register clock %s\n", __func__, clks[i].name);
+			continue;
+		}
+
+		data->clk_data.clks[clks[i].id] = clk;
+		p_clk++;
+		kfree(name);
+		if (parent_name) {
+			kfree(parent_name);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_pll);
+
+int eswin_clk_register_fixed_factor(const struct eswin_fixed_factor_clock *clks,
+					   int nums,
+					   struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+
+		clk = clk_register_fixed_factor(NULL, name,
+						parent_name,
+						clks[i].flags, clks[i].mult,
+						clks[i].div);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		data->clk_data.clks[clks[i].id] = clk;
+
+		kfree(name);
+		kfree(parent_name);
+	}
+
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_fixed_factor(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_fixed_factor);
+
+int eswin_clk_register_mux(const struct eswin_mux_clock *clks,
+				  int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	int j;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+
+		char **parent_names = kzalloc(sizeof(char *) * clks[i].num_parents,
+			GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+		}
+		for (j = 0; j < clks[i].num_parents; j++) {
+			parent_names[j] = kzalloc(strlen(clks[i].parent_names[j])
+				+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+			if (data->numa_id < 0) {
+				sprintf(parent_names[j], "%s", clks[i].parent_names[j]);
+			} else {
+				sprintf(parent_names[j], "d%d_%s",
+					data->numa_id, clks[i].parent_names[j]);
+			}
+		}
+		clk = clk_register_mux_table(NULL, name,
+				(const char * const*)parent_names,
+				clks[i].num_parents, clks[i].flags,
+				base + clks[i].offset, clks[i].shift,
+				clks[i].mask, clks[i].mux_flags,
+				clks[i].table, &data->lock);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			for (j = 0; j < clks[i].num_parents; j++) {
+				kfree(parent_names[j]);
+			}
+			kfree(parent_names);
+			goto err;
+		}
+
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+
+		kfree(name);
+		for (j = 0; j < clks[i].num_parents; j++) {
+			kfree(parent_names[j]);
+		}
+		kfree(parent_names);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_mux(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_mux);
+
+int eswin_clk_register_divider(const struct eswin_divider_clock *clks,
+				      int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	struct clk_hw *clk_hw;
+	struct clk_hw *parent_hw;
+	struct clk_parent_data	parent_data;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		parent_hw = eswin_clk_find_parent(data, parent_name);
+		parent_data.name = parent_name;
+		parent_data.hw = parent_hw;
+		parent_data.fw_name = NULL;
+		clk_hw = clk_hw_register_divider_table_parent_data(NULL, name,
+						&parent_data,
+						clks[i].flags,
+						base + clks[i].offset,
+						clks[i].shift, clks[i].width,
+						clks[i].div_flags,
+						clks[i].table,
+						&data->lock);
+		if (IS_ERR(clk_hw)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		clk = clk_hw->clk;
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_divider(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_divider);
+
+int eswin_clk_register_gate(const struct eswin_gate_clock *clks,
+				       int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	struct clk_hw *clk_hw;
+	struct clk_hw *parent_hw;
+	struct clk_parent_data	parent_data;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		parent_hw = eswin_clk_find_parent(data, parent_name);
+		parent_data.name = parent_name;
+		parent_data.hw = parent_hw;
+		parent_data.fw_name = NULL;
+		clk_hw = clk_hw_register_gate_parent_data(NULL, name,
+				&parent_data,
+				clks[i].flags,
+				base + clks[i].offset,
+				clks[i].bit_idx,
+				clks[i].gate_flags,
+				&data->lock);
+		if (IS_ERR(clk_hw)) {
+			pr_err("%s: failed to register clock %s\n",__func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		clk = clk_hw->clk;
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_gate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_gate);
+
+static const struct clk_ops clk_dummpy_ops = {
+
+};
+
+struct clk *eswin_register_clk(struct eswin_clock_data *data,
+				     struct device *dev, const char *name,
+				      const char *parent_name,
+				      unsigned long flags,
+				      spinlock_t *lock)
+{
+	struct eswin_clock *eclk;
+	struct clk *clk;
+	struct clk_init_data init;
+	struct clk_parent_data	parent_data;
+	struct clk_hw 		*parent_hw;
+
+	eclk = kzalloc(sizeof(*eclk), GFP_KERNEL );
+	if (!eclk)
+		return ERR_PTR(-ENOMEM);
+
+	init.ops = &clk_dummpy_ops;
+
+	init.name = name;
+	init.flags = flags;
+	init.parent_names = NULL;
+	init.num_parents = (parent_name ? 1 : 0);
+	init.parent_data = &parent_data;
+
+	parent_hw = eswin_clk_find_parent(data, (char *)parent_name);
+	parent_data.name = parent_name;
+	parent_data.hw = parent_hw;
+	parent_data.fw_name = NULL;
+
+	eclk->hw.init = &init;
+
+	clk = clk_register(dev, &eclk->hw);
+	if (IS_ERR(clk))
+		kfree(eclk);
+
+	return clk;
+}
+
+int eswin_clk_register_clk(const struct eswin_clock *clks,
+				       int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int 	i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		clk = eswin_register_clk(data, NULL, name, parent_name,
+					clks[i].flags, &data->lock);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+err:
+	while (i--)
+		clk_unregister_gate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_clk);
--- /dev/null
+++ b/drivers/clk/eswin/clk.h
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#ifndef	__ESWIN_CLK_H
+#define	__ESWIN_CLK_H
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+
+struct platform_device;
+
+struct eswin_clock_data {
+	struct clk_onecell_data	clk_data;
+	void __iomem		*base;
+	int 			numa_id;
+	spinlock_t 		lock;
+};
+
+struct eswin_clock {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	struct clk_hw		hw;
+	const char		*alias;
+};
+
+struct eswin_fixed_rate_clock {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		fixed_rate;
+};
+
+struct eswin_fixed_factor_clock {
+	unsigned int		id;
+	char				*name;
+	const char			*parent_name;
+	unsigned long		mult;
+	unsigned long		div;
+	unsigned long		flags;
+};
+
+struct eswin_mux_clock {
+	unsigned int		id;
+	const char			*name;
+	const char	*const 	*parent_names;
+	u8					num_parents;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8					shift;
+	u32 				mask;
+	u8					mux_flags;
+	u32					*table;
+	const char			*alias;
+};
+
+
+struct eswin_divider_clock {
+	unsigned int		id;
+	const char		*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8			shift;
+	u8			width;
+	u8			div_flags;
+	struct clk_div_table	*table;
+	const char		*alias;
+};
+
+struct eswin_gate_clock {
+	unsigned int		id;
+	const char		*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8			bit_idx;
+	u8			gate_flags;
+	const char		*alias;
+};
+
+struct eswin_pll_clock {
+	u32	id;
+	const char	*name;
+	const char	*parent_name;
+	const u32	ctrl_reg0;
+	const u8	pllen_shift;
+	const u8	pllen_width;
+	const u8	refdiv_shift;
+	const u8	refdiv_width;
+	const u8	fbdiv_shift;
+	const u8	fbdiv_width;
+
+	const u32	ctrl_reg1;
+	const u8	frac_shift;
+	const u8	frac_width;
+
+	const u32	ctrl_reg2;
+	const u8	postdiv1_shift;
+	const u8	postdiv1_width;
+	const u8	postdiv2_shift;
+	const u8	postdiv2_width;
+
+	const u32	status_reg;
+	const u8	lock_shift;
+	const u8	lock_width;
+};
+
+struct eswin_clk_pll {
+	struct clk_hw	hw;
+	u32	id;
+	int 	numa_id;
+	void __iomem	*ctrl_reg0;
+	u8	pllen_shift;
+	u8	pllen_width;
+	u8	refdiv_shift;
+	u8	refdiv_width;
+	u8	fbdiv_shift;
+	u8	fbdiv_width;
+
+	void __iomem	*ctrl_reg1;
+	u8	frac_shift;
+	u8	frac_width;
+
+	void __iomem	*ctrl_reg2;
+	u8	postdiv1_shift;
+	u8	postdiv1_width;
+	u8	postdiv2_shift;
+	u8	postdiv2_width;
+
+	void __iomem	*status_reg;
+	u8	lock_shift;
+	u8	lock_width;
+};
+
+struct eswin_clock_data *eswin_clk_init(struct platform_device *, int);
+int eswin_clk_register_fixed_rate(const struct eswin_fixed_rate_clock *,
+				int, struct eswin_clock_data *);
+
+void eswin_clk_register_pll(struct eswin_pll_clock *clks,
+		int nums, struct eswin_clock_data *data, struct device *dev);
+
+int eswin_clk_register_fixed_factor(const struct eswin_fixed_factor_clock *,
+				int, struct eswin_clock_data *);
+int eswin_clk_register_mux(const struct eswin_mux_clock *, int,
+				struct eswin_clock_data *);
+
+int eswin_clk_register_divider(const struct eswin_divider_clock *,
+				int, struct eswin_clock_data *);
+int eswin_clk_register_gate(const struct eswin_gate_clock *,
+				int, struct eswin_clock_data *);
+
+int eswin_clk_register_clk(const struct eswin_clock *,
+				       int , struct eswin_clock_data *);
+
+#define eswin_clk_unregister(type) \
+static inline \
+void eswin_clk_unregister_##type(const struct eswin_##type##_clock *clks, \
+				int nums, struct eswin_clock_data *data) \
+{ \
+	struct clk **clocks = data->clk_data.clks; \
+	int i; \
+	for (i = 0; i < nums; i++) { \
+		int id = clks[i].id; \
+		if (clocks[id])  \
+			clk_unregister_##type(clocks[id]); \
+	} \
+}
+
+eswin_clk_unregister(fixed_rate)
+eswin_clk_unregister(fixed_factor)
+eswin_clk_unregister(mux)
+eswin_clk_unregister(divider)
+eswin_clk_unregister(gate)
+
+#endif	/* __ESWIN_CLK_H */
--- /dev/null
+++ b/drivers/clk/eswin/test/Kconfig
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config COMMON_CLK_WIN2030_TEST
+	bool "Win2030 Clock Driver Test"
+	default y
+	help
+	  Build the Eswin Win2030 clock test driver
--- /dev/null
+++ b/drivers/clk/eswin/test/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Eswin Clock test specific Makefile
+#
+
+obj-$(CONFIG_COMMON_CLK_WIN2030_TEST)	+= clk_test_kmd.o
--- /dev/null
+++ b/drivers/clk/eswin/test/clk_test_kmd.c
@@ -0,0 +1,425 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+/*
+	1.mount -t debugfs none /sys/kernel/debug
+*/
+#define CLKDBG_ARGS_MAX			3
+#define CLKDBG_INSTR_MAX_LEN	128
+#define CLKDBG_DEFAULT_SEP_STR	" \n"
+
+enum {
+	CLKDBG_CMD_ENABLE,
+	CLKDBG_CMD_DISABLE,
+	CLKDBG_CMD_PREPARE,
+	CLKDBG_CMD_UNPREPARE,
+	CLKDBG_CMD_PREPARE_ENABLE,
+	CLKDBG_CMD_DISABLE_UNPREPARE,
+	CLKDBG_CMD_SETRATE,
+	CLKDBG_CMD_ROUNDRATE,
+	CLKDBG_CMD_GETRATE,
+	CLKDBG_CMD_SETPARENT,
+	CLKDBG_CMD_GETPARENT,
+	CLKDBG_CMD_NR,
+};
+
+enum {
+	CLKDBG_ERR_NO = 0x0,
+	CLKDBG_ERR_PARSE_CMD = 0x1,
+	CLKDBG_ERR_PARSE_SELF = 0x2,
+	CLKDBG_ERR_PARSE_ARGS = 0x4,
+	CLKDBG_ERR_EXEC_CMD = 0x10,
+};
+#define CLKDBG_ERR_PARSE	(CLKDBG_ERR_PARSE_CMD |\
+							CLKDBG_ERR_PARSE_SELF |\
+							CLKDBG_ERR_PARSE_ARGS)
+#define CLKDBG_ERR_EXEC		(CLKDBG_ERR_EXEC_CMD)
+
+enum {
+	CLKDBG_STS_COMPLETE,
+	CLKDBG_STS_START,
+};
+
+struct cmd_packet {
+	unsigned int cmd;
+	struct clk *self;
+	struct clk_hw *self_hw;
+	struct clk *parent;
+	struct clk_hw *parent_hw;
+	unsigned long rate;
+	int result;
+	int status;
+};
+
+struct clkdbg {
+	void *instr;
+	struct dentry *clkdbg_dir;
+	struct cmd_packet *cmdp;
+};
+
+static struct clkdbg *clkdbg = NULL;
+
+static const char * const cmd_str[CLKDBG_CMD_NR] = {
+	"enable",
+	"disable",
+	"prepare",
+	"unprepare",
+	"prepare_enable",
+	"disable_unprepare",
+	"set_rate",
+	"round_rate",
+	"get_rate",
+	"set_parent",
+	"get_parent",
+};
+
+static const char * const hlp_str[CLKDBG_CMD_NR] = {
+	"enable\t\t\t: echo enable {clk} > clkdbg\n",
+	"disable\t\t\t: echo disable {clk} > clkdbg\n",
+	"prepare\t\t\t: echo prepare {clk} > clkdbg\n",
+	"unprepare\t\t: echo unprepare {clk} > clkdbg\n",
+	"prepare_enable\t\t: echo prepare {clk} > clkdbg\n",
+	"disable_unprepare\t: echo unprepare {clk} > clkdbg\n",
+	"set_rate\t\t: echo set_rate {clk} {rate(Hz)} > clkdbg\n",
+	"round_rate\t\t: echo round_rate {clk} {rate(Hz)} > clkdbg\n",
+	"get_rate\t\t: echo get_rate {clk} > clkdbg\n",
+	"set_parent\t\t: echo set_parent {clk} {parent} > clkdbg\n",
+	"get_parent\t\t: echo get_parent {clk} > clkdbg\n",
+};
+
+static int clkdbg_parse_cmd(char **str, char *sep,
+							struct cmd_packet *cmdp)
+{
+	char *str_sec;
+	int ret, cmd = 0;
+
+	/* parse the first section string. */
+	str_sec = strsep(str, sep);
+	if (str_sec == NULL)
+		return -EINVAL;
+
+	/*
+	 * search request keyword to find predefined keywords:
+	 * enable, disable, prepare, unprepare, set_rate, set_parent.
+	 */
+	do {
+		ret = strcmp(str_sec, cmd_str[cmd]);
+	} while (ret && (++cmd < CLKDBG_CMD_NR));
+
+	/* assign and record command value. */
+	cmdp->cmd = cmd;
+
+	pr_info("cmd: %d\n", cmdp->cmd);
+
+	return ret;
+}
+
+static int clkdbg_parse_selfclk(char **str, char *sep,
+								  struct cmd_packet *cmdp)
+{
+	char *str_sec;
+
+	/* parse the self clock name. */
+	str_sec = strsep(str, sep);
+	if (str_sec == NULL)
+		return -EINVAL;
+
+	/*
+	 * try to lookup self clock reference, and return directly
+	 * if failed.
+	 */
+	cmdp->self = __clk_lookup(str_sec);
+	if (!cmdp->self)
+		return -EINVAL;
+
+	cmdp->self_hw = __clk_get_hw(cmdp->self);
+
+	pr_info("self: \"%s\"\n", __clk_get_name(cmdp->self));
+
+	return 0;
+}
+
+static int clkdbg_parse_args(char **str, char *sep,
+							 struct cmd_packet *cmdp)
+{
+	char *args[CLKDBG_ARGS_MAX];
+	int idx = 0, ret = 0;
+
+	/* parse argument list and store them. */
+	do {
+		args[idx] = strsep(str, sep);
+	} while (args[idx] && (++idx < CLKDBG_ARGS_MAX));
+
+	switch (cmdp->cmd) {
+	case CLKDBG_CMD_SETRATE:
+	case CLKDBG_CMD_ROUNDRATE:
+		ret = kstrtoul(args[0], 0, &cmdp->rate);
+		pr_info("rate: %ld\n", cmdp->rate);
+		break;
+	case CLKDBG_CMD_SETPARENT:
+		cmdp->parent = __clk_lookup(args[0]);
+		if (!cmdp->parent)
+			ret = -EINVAL;
+		pr_info("parent: \"%s\"\n", __clk_get_name(cmdp->parent));
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static int clkdbg_parse_str(char **str, char *sep,
+							struct cmd_packet *cmdp)
+{
+	int ret = 0;
+
+	ret = clkdbg_parse_cmd(str, sep, cmdp);
+	if (ret) {
+		cmdp->result = CLKDBG_ERR_PARSE_CMD;
+		goto out;
+	}
+
+	ret = clkdbg_parse_selfclk(str, sep, cmdp);
+	if (ret) {
+		cmdp->result = CLKDBG_ERR_PARSE_SELF;
+		goto out;
+	}
+
+	ret = clkdbg_parse_args(str, sep, cmdp);
+	if (ret) {
+		cmdp->result = CLKDBG_ERR_PARSE_ARGS;
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int clkdbg_execute_cmd(struct clkdbg *clkdbg)
+{
+	struct cmd_packet *cmdp = clkdbg->cmdp;
+	int ret = 0;
+
+	switch (cmdp->cmd) {
+	case CLKDBG_CMD_PREPARE:
+		ret = clk_prepare(cmdp->self);
+		break;
+	case CLKDBG_CMD_UNPREPARE:
+		clk_unprepare(cmdp->self);
+		break;
+	case CLKDBG_CMD_ENABLE:
+		ret = clk_enable(cmdp->self);
+		break;
+	case CLKDBG_CMD_DISABLE:
+		clk_disable(cmdp->self);
+		break;
+	case CLKDBG_CMD_PREPARE_ENABLE:
+		ret = clk_prepare_enable(cmdp->self);
+		break;
+	case CLKDBG_CMD_DISABLE_UNPREPARE:
+		clk_disable_unprepare(cmdp->self);
+		break;
+	case CLKDBG_CMD_SETRATE:
+		ret = clk_set_rate(cmdp->self, cmdp->rate);
+		break;
+	case CLKDBG_CMD_ROUNDRATE:
+		ret = clk_round_rate(cmdp->self, cmdp->rate);
+		if (ret >= 0) {
+			cmdp->rate = ret;
+			ret = 0;
+		}
+		break;
+	case CLKDBG_CMD_GETRATE:
+		cmdp->rate = clk_get_rate(cmdp->self);
+		break;
+	case CLKDBG_CMD_SETPARENT:
+		ret = clk_set_parent(cmdp->self, cmdp->parent);
+		break;
+	case CLKDBG_CMD_GETPARENT:
+		cmdp->parent = clk_get_parent(cmdp->self);
+		cmdp->parent_hw = __clk_get_hw(cmdp->parent);
+		break;
+	default:
+		break;
+	}
+
+	if (ret)
+		cmdp->result = CLKDBG_ERR_EXEC_CMD;
+
+	return ret;
+}
+
+static ssize_t clkdbg_write(struct file *filp,
+							const char __user *userbuf,
+							size_t count, loff_t *ppos)
+{
+	struct clkdbg *clkdbg =
+			((struct seq_file *)filp->private_data)->private;
+	struct cmd_packet *cmdp = clkdbg->cmdp;
+	char *sep = CLKDBG_DEFAULT_SEP_STR;
+	char *instr = clkdbg->instr;
+	int ret;
+
+	memset(instr, 0x0, CLKDBG_INSTR_MAX_LEN);
+	memset(cmdp, 0x0, sizeof(*cmdp));
+	clkdbg->cmdp->status = CLKDBG_STS_START;
+	clkdbg->cmdp->result = CLKDBG_ERR_NO;
+
+	ret = copy_from_user(instr, userbuf, count);
+	if (ret) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	/*
+	 * parse the input string and write cmd, argument list,
+	 * self clock and parent(if exists) into cmd_packet struct.
+	 */
+	ret = clkdbg_parse_str(&instr, sep, cmdp);
+	if (ret < 0)
+		goto out;
+
+	/* execute clock command. */
+	ret = clkdbg_execute_cmd(clkdbg);
+
+out:
+	return count;
+}
+
+static int clkdbg_show(struct seq_file *s, void *data)
+{
+	struct clkdbg *clkdbg = (struct clkdbg *)s->private;
+	struct cmd_packet *cmdp = clkdbg->cmdp;
+	struct clk_hw *clk_hw;
+	//const char *pname_c, *pname;
+	int idx, num_parents;
+
+	/* default helper string printed. */
+	if (cmdp->status == CLKDBG_STS_COMPLETE) {
+		for (idx = CLKDBG_CMD_ENABLE; idx < CLKDBG_CMD_NR; idx++)
+			seq_printf(s, "%s", hlp_str[idx]);
+		return 0;
+	}
+
+	if (cmdp->result & CLKDBG_ERR_PARSE) {
+		seq_printf(s, "parse cmd string failed(%d)!\n", cmdp->result);
+		goto out;
+	}
+
+	seq_printf(s, "%s \"%s\"",
+			   cmd_str[cmdp->cmd], __clk_get_name(cmdp->self));
+
+	switch (cmdp->cmd) {
+	case CLKDBG_CMD_SETRATE:
+	case CLKDBG_CMD_ROUNDRATE:
+		seq_printf(s, " as %ld ", cmdp->rate);
+		break;
+	case CLKDBG_CMD_GETRATE:
+		seq_printf(s, ":\n\t%ld Hz\n", cmdp->rate);
+		break;
+	case CLKDBG_CMD_SETPARENT:
+		seq_printf(s, " as \"%s\" ", __clk_get_name(cmdp->parent));
+		break;
+	case CLKDBG_CMD_GETPARENT:
+		seq_puts(s, ":\n");
+		num_parents = clk_hw_get_num_parents(cmdp->self_hw);
+		for (idx = 0; idx < num_parents; idx++) {
+			clk_hw = clk_hw_get_parent_by_index(cmdp->self_hw, idx);
+			if (clk_hw == cmdp->parent_hw)
+				seq_puts(s, "\t[*]");
+			else
+				seq_puts(s, "\t[ ]");
+
+			seq_printf(s, "%s\n", __clk_get_name(clk_hw->clk));
+		}
+		break;
+	default:
+		break;
+	}
+
+	seq_printf(s, "%s\n", cmdp->result ? "failed" : "success");
+
+out:
+	cmdp->status = CLKDBG_STS_COMPLETE;
+
+	return 0;
+}
+
+static int clkdbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clkdbg_show, inode->i_private);
+}
+
+static const struct file_operations clkdbg_ops = {
+	.owner		= THIS_MODULE,
+	.open		= clkdbg_open,
+	.release	= single_release,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= clkdbg_write,
+};
+
+static int clkdbg_add_debugfs(void)
+{
+	if (!debugfs_initialized())
+		return 0;
+
+	clkdbg->clkdbg_dir = debugfs_create_file("clkdbg", 0600, NULL, clkdbg, &clkdbg_ops);
+
+	return 0;
+}
+
+static int __init clkdbg_init(void)
+{
+	clkdbg = kzalloc(sizeof(*clkdbg), GFP_KERNEL);
+	if (!clkdbg)
+		return -ENOMEM;
+
+	clkdbg->instr = kzalloc(CLKDBG_INSTR_MAX_LEN, GFP_KERNEL);
+	if (!clkdbg->instr)
+		return -ENOMEM;
+
+	clkdbg->cmdp = kzalloc(sizeof(struct cmd_packet), GFP_KERNEL);
+	if (!clkdbg->instr)
+		return -ENOMEM;
+
+	return clkdbg_add_debugfs();
+}
+
+static void __exit clkdbg_exit(void)
+{
+	if (clkdbg && clkdbg->clkdbg_dir)
+		debugfs_remove_recursive(clkdbg->clkdbg_dir);
+
+	if (clkdbg)
+		kfree(clkdbg);
+}
+
+module_init(clkdbg_init);
+module_exit(clkdbg_exit);
+
+MODULE_DESCRIPTION("CCF Debug Driver");
+MODULE_AUTHOR("Shunli Wang <wangshunli@cambricon.com>");
+MODULE_LICENSE("GPL v2");
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -319,6 +319,12 @@ config RESET_ZYNQ
 	  This enables the reset controller driver for Xilinx Zynq SoCs.
 
 source "drivers/reset/starfive/Kconfig"
+
+config RESET_ESWIN_WIN2030
+	tristate "Eswin Win2030 Reset Driver"
+	default n
+	help
+	  This enables the reset controller driver for Eswin Win2030 SoCs.
 source "drivers/reset/sti/Kconfig"
 source "drivers/reset/hisilicon/Kconfig"
 source "drivers/reset/tegra/Kconfig"
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -41,3 +41,5 @@ obj-$(CONFIG_RESET_UNIPHIER) += reset-un
 obj-$(CONFIG_RESET_UNIPHIER_GLUE) += reset-uniphier-glue.o
 obj-$(CONFIG_RESET_ZYNQ) += reset-zynq.o
 obj-$(CONFIG_ARCH_ZYNQMP) += reset-zynqmp.o
+obj-$(CONFIG_RESET_ESWIN_WIN2030) += reset-eswin.o
+
--- /dev/null
+++ b/drivers/reset/reset-eswin.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Reset Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#define SYSCRG_CLEAR_BOOT_INFO_OFFSET		(0x30C)
+#define CLEAR_BOOT_FLAG_BIT			BIT_ULL(0)
+
+#define SYSCRG_RESET_OFFSET			(0x400)
+
+/**
+ * struct eswin_reset_data - reset controller information structure
+ * @rcdev: reset controller entity
+ * @dev: reset controller device pointer
+ * @idr: idr structure for mapping ids to reset control structures
+ */
+struct eswin_reset_data {
+	struct reset_controller_dev rcdev;
+	struct device *dev;
+	struct idr idr;
+	struct regmap *regmap;
+};
+
+/**
+ * struct eswin_reset_control - reset control structure
+ * @dev_id: SoC-specific device identifier
+ * @reset_bit: reset mask to use for toggling reset
+ */
+struct eswin_reset_control {
+	u32 dev_id;
+	u32 reset_bit;
+};
+
+
+#define to_eswin_reset_data(p)	\
+	container_of((p), struct eswin_reset_data, rcdev)
+
+/**
+ * eswin_reset_set() - program a device's reset
+ * @rcdev: reset controller entity
+ * @id: ID of the reset to toggle
+ * @assert: boolean flag to indicate assert or deassert
+ *
+ * This is a common internal function used to assert or deassert a device's
+ * reset by clear and set the reset bit. The device's reset is asserted if the
+ * @assert argument is true, or deasserted if @assert argument is false.
+ *
+ * Return: 0 for successful request, else a corresponding error value
+ */
+static int eswin_reset_set(struct reset_controller_dev *rcdev,
+			    unsigned long id, bool assert)
+{
+	struct eswin_reset_data *data = to_eswin_reset_data(rcdev);
+	struct eswin_reset_control *control;
+	int ret;
+
+	control = idr_find(&data->idr, id);
+
+	dev_dbg(rcdev->dev, "dev_id 0x%x reset_bit 0x%x assert 0x%x\r\n",
+		control->dev_id, control->reset_bit, assert);
+
+	if (!control)
+		return -EINVAL;
+
+	if (assert) {
+		ret = regmap_clear_bits(data->regmap, SYSCRG_RESET_OFFSET + control->dev_id * sizeof(u32),
+			control->reset_bit);
+	} else {
+		ret = regmap_set_bits(data->regmap, SYSCRG_RESET_OFFSET + control->dev_id * sizeof(u32),
+			control->reset_bit);
+	}
+
+	return ret;
+}
+
+static int eswin_reset_reset(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	int ret;
+
+	//todo, check weather this should be removed
+	/*clear boot flag so u84 and scpu could be reseted by software*/
+	/*
+	struct eswin_reset_data *data = to_eswin_reset_data(rcdev);
+	printk("%s %d\r\n",__func__,__LINE__);
+	regmap_set_bits(data->regmap, SYSCRG_CLEAR_BOOT_INFO_OFFSET, CLEAR_BOOT_FLAG_BIT);
+	msleep(50);
+	regmap_clear_bits(data->regmap, SYSCRG_CLEAR_BOOT_INFO_OFFSET, CLEAR_BOOT_FLAG_BIT);
+	*/
+
+	ret = eswin_reset_set(rcdev, id, true);
+	if (0 != ret) {
+		return ret;
+	}
+	usleep_range(10, 15);
+	ret = eswin_reset_set(rcdev, id, false);
+	if (0 != ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int eswin_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	return eswin_reset_set(rcdev, id, true);
+}
+
+static int eswin_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	return eswin_reset_set(rcdev, id, false);
+}
+
+static const struct reset_control_ops eswin_reset_ops = {
+	.reset		= eswin_reset_reset,
+	.assert		= eswin_reset_assert,
+	.deassert	= eswin_reset_deassert,
+};
+
+static int eswin_reset_of_xlate_lookup_id(int id, void *p, void *data)
+{
+	struct of_phandle_args *reset_spec = (struct of_phandle_args *)data;
+	struct eswin_reset_control *slot_control = (struct eswin_reset_control *)p;
+
+	if (reset_spec->args[0] == slot_control->dev_id
+		&& reset_spec->args[1] == slot_control->reset_bit) {
+			return id;
+	} else {
+		return 0;
+	}
+}
+
+/**
+ * eswin_reset_of_xlate() - translate a set of OF arguments to a reset ID
+ * @rcdev: reset controller entity
+ * @reset_spec: OF reset argument specifier
+ *
+ * This function performs the translation of the reset argument specifier
+ * values defined in a reset consumer device node. The function allocates a
+ * reset control structure for that device reset, and will be used by the
+ * driver for performing any reset functions on that reset. An idr structure
+ * is allocated and used to map to the reset control structure. This idr
+ * is used by the driver to do reset lookups.
+ *
+ * Return: 0 for successful request, else a corresponding error value
+ */
+static int eswin_reset_of_xlate(struct reset_controller_dev *rcdev,
+				 const struct of_phandle_args *reset_spec)
+{
+	struct eswin_reset_data *data = to_eswin_reset_data(rcdev);
+	struct eswin_reset_control *control;
+	int ret;
+
+	if (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))
+		return -EINVAL;
+
+	ret = idr_for_each(&data->idr, eswin_reset_of_xlate_lookup_id, (void *)reset_spec);
+	if (0 != ret) {
+		return ret;
+	}
+
+	control = devm_kzalloc(data->dev, sizeof(*control), GFP_KERNEL);
+	if (!control)
+		return -ENOMEM;
+
+	control->dev_id = reset_spec->args[0];
+	control->reset_bit = reset_spec->args[1];
+
+	return idr_alloc(&data->idr, control, 0, 0, GFP_KERNEL);
+}
+
+static const struct of_device_id eswin_reset_dt_ids[] = {
+	 { .compatible = "eswin,win2030-reset", },
+	 { /* sentinel */ },
+};
+
+static int eswin_reset_probe(struct platform_device *pdev)
+{
+	struct eswin_reset_data *data;
+	struct device *parent;
+
+	parent = pdev->dev.parent;
+	if (!parent) {
+		dev_err(&pdev->dev, "no parent\n");
+		return -ENODEV;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->regmap = syscon_node_to_regmap(parent->of_node);
+	if (IS_ERR(data->regmap)) {
+		dev_err(&pdev->dev, "failed to get parent regmap\n");
+		return PTR_ERR(data->regmap);
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.ops = &eswin_reset_ops;
+	data->rcdev.of_node = pdev->dev.of_node;
+	data->rcdev.of_reset_n_cells = 2;
+	data->rcdev.of_xlate = eswin_reset_of_xlate;
+	data->rcdev.dev = &pdev->dev;
+	data->dev = &pdev->dev;
+	idr_init(&data->idr);
+
+	/*clear boot flag so u84 and scpu could be reseted by software*/
+	regmap_set_bits(data->regmap, SYSCRG_CLEAR_BOOT_INFO_OFFSET, CLEAR_BOOT_FLAG_BIT);
+	msleep(50);
+	//regmap_clear_bits(data->regmap, SYSCRG_CLEAR_BOOT_INFO_OFFSET, CLEAR_BOOT_FLAG_BIT);
+
+	platform_set_drvdata(pdev, data);
+
+	return devm_reset_controller_register(&pdev->dev, &data->rcdev);
+}
+
+static int eswin_reset_remove(struct platform_device *pdev)
+{
+	struct eswin_reset_data *data = platform_get_drvdata(pdev);
+
+	idr_destroy(&data->idr);
+
+	return 0;
+}
+
+static struct platform_driver eswin_reset_driver = {
+	.probe	= eswin_reset_probe,
+	.remove = eswin_reset_remove,
+	.driver = {
+		.name		= "eswin-reset",
+		.of_match_table	= eswin_reset_dt_ids,
+	},
+};
+
+static int __init win2030_reset_init(void)
+{
+	return platform_driver_register(&eswin_reset_driver);
+}
+arch_initcall(win2030_reset_init);
